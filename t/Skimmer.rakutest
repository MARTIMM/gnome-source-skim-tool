use Gnome::SourceSkimTool::ConstEnumType;
use Gnome::SourceSkimTool::Prepare;
use Gnome::SourceSkimTool::SkimGtkDoc;

use Test;

#-------------------------------------------------------------------------------
constant \Prepare = Gnome::SourceSkimTool::Prepare;

# pick a class with no other prefix specified
my Str $*sub-prefix;
#my Str $*other-prefix = 'gtk_button';

my Bool $*verbose = False;

#TODO; get from hierargy
my Bool $*class-is-leaf = False;
my Bool $*class-is-top = False;

#TODO; get from gtk docs
my Bool $*class-is-role = False; # is leaf implicitly


# needed dynamic variable set by main program
my SkimSource $*use-doc-source;
my Str $*library;

#-------------------------------------------------------------------------------
my Prepare $gfl;
my Gnome::SourceSkimTool::SkimGtkDoc $sgd;
my Int $level;

#`{{
#-------------------------------------------------------------------------------
subtest 'Prepare', {

  # read from 'gtkbutton.xml'
  $*sub-prefix = 'gtk_button';
  $level = 0;

  # dies because tests are not done in a gnome raku repo
  dies-ok { $gfl .= new; }, 'dies when no path set/found';
  $gfl .= new(:test-cwd<gnome-gtk3>);

  is $gfl.set-source-dir,
    ( [~] SKIMTOOLROOT, 'Gnome/gtk+-', VGtk3, '/gtk' ),
    '.set-source-dir()';
  is $*use-doc-source, Gtk3, 'check $*use-doc-source: ' ~ $*use-doc-source;

  my Str $gd = $gfl.set-gtkdoc-dir;
  ok $gd ~~ m/ 'Gtkdoc/Gtk3' $/, '.set-gtkdoc-dir()';
  ok $gd.IO.d, 'check dir: ' ~ $gd;

  if "$gd/docs".IO ~~ :d {
    skip 'Don\'t need to do long running test all the time', 1;
  }

  else {
    $gfl.generate-gtkdoc;
  }

  ok "$gd/gtk3-sections.txt".IO.r, 'check phase 1: ' ~ "$gd/gtk3-sections.txt";
  ok "$gd/docs".IO.d, 'check dir: ' ~ "$gd/docs";
  ok "$gd/docs/gtkaboutdialog.xml".IO.r,
      'check phase 3: ' ~ "$gd/docs/gtkaboutdialog.xml";

  is $*library, '&gtk-lib', 'check $*library: ' ~ $*library;
  is $gfl.set-skim-result-file, SKIMTOOLDATA ~ 'Gtk3/GtkButton.yaml',
    '.set-skim-result-file()';
  is RAKUMODS, 'xt/NewRakuModules/', 'check RAKUMODS: ' ~ RAKUMODS;
}

#-------------------------------------------------------------------------------
subtest 'DocSearch', {

  $level = 0;
  $sgd .= new;
  $sgd.process-gtkdocs(:test-cwd<gnome-gtk3>);

#  display-function-info(%(:doc($sgd.description)));
#  display-function-info($sgd.functions);
#  display-function-info($sgd.signals);
#  display-function-info($sgd.properties);
#  display-function-info($sgd.objects);

  like $sgd.description, / '=head1' \s+ Description /,
       '.process-gtkdocs(): description';
  ok $sgd.functions<gtk-button-new>:exists,
       '.process-gtkdocs(): functions';
  ok $sgd.signals<GtkButton-released>:exists,
       '.process-gtkdocs(): signals';
  ok $sgd.properties<GtkButton--use-underline>:exists,
       '.process-gtkdocs(): properties';

  $sgd.process-apidocs(:test-cwd<gnome-gtk3>);
  is $sgd.objects<gtk_window_set_icon><object>, 'GtkWindow', '.process-apidocs(): api doc';

  ok $sgd.objects<gtk_button_get_alignment><deprecated>,
    'function gtk_button_get_alignment is deprecated';
  ok $sgd.objects<GtkButton::leave><deprecated>,
       'signal ::leave is deprecated';
  ok $sgd.objects<GtkButton:yalign><deprecated>,
       'property :yalign is deprecated';
}
}}

#-------------------------------------------------------------------------------
subtest 'types and enums', {
#DONE; types and enums
#TODO: add enum values to objects.yaml
  $level = 0;

  # change module to test for structures defining enums
  $*sub-prefix = 'gtk_window';

  $gfl .= new(:test-cwd<gnome-gtk3>);
  my Str $gd = $gfl.set-gtkdoc-dir;
  $sgd .= new;
#  $sgd.process-gtkdocs(:test-cwd<gnome-gtk3>);

#  display-function-info($sgd.types);

  $sgd.process-apidocs(:test-cwd<gnome-gtk3>);
}

#TODO Get hierargy of modules. add info to objects.yaml
#TODO Add callback arg count to signals
#TODO rename 1st arg to :$_widget and drop last user data pointer
#TODO generate Raku module
#TODO test dump of generated Raku module
#-------------------------------------------------------------------------------
done-testing;

#BUG; module result of function not always correct, name has wrong text

#-------------------------------------------------------------------------------
sub display-function-info ( Hash $info ) {
  for $info.keys.sort -> $k {
    say '' if $level == 0;
    if $info{$k} ~~ Hash {
      say '  ' x $level, $k, ':';
      $level++;
      display-function-info($info{$k});
      $level--;
    }

    else {
      say '  ' x $level, $k, ': ', $info{$k}.gist;
    }
  }
}

=finish

