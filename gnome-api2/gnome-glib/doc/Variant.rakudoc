 use v6.d;

 =begin pod
 =head2 Project Description
 =item B<Distribution:> Gnome::Glib
 =item B<Project description:> Modules for package Gnome::Glib:api<2>. The language binding to GNOME's lowest level library
 =item B<Project version:> 0.1.5
 =item B<Rakudo version:> 6.d, 2023.10.67.g.688.b.625.ac
 =item B<Author:> Marcel Timmerman
 =end pod


#-------------------------------------------------------------------------------
#--[Class Description]----------------------------------------------------------
#-------------------------------------------------------------------------------

=begin pod

![](images/variant.png)

=head1 Description

GVariant is a variant datatype; it can contain one or more values
along with information about the type of the values.

A GVariant may contain simple types, like an integer, or a boolean value;
or complex types, like an array of two strings, or a dictionary of key
value pairs. A GVariant is also immutable: once it's been created neither
its type nor its content can be modified further.

GVariant is useful whenever data needs to be serialized, for example when
sending method parameters in D-Bus, or when saving settings using GSettings.

When creating a new GVariant, you pass the data you want to store in it
along with a string representing the type of data you wish to pass to it.

For instance, if you want to create a GVariant holding an integer value you
can use:

=begin comment

  GVariant *v = g_variant_new ("u", 40);
=end comment


The string "u" in the first argument tells GVariant that the data passed to
the constructor (40) is going to be an unsigned integer.

More advanced examples of GVariant in use can be found in documentation for GVariant format strings.

The range of possible values is determined by the type.

The type system used by GVariant is GVariantType.

GVariant instances always have a type and a value (which are given
at construction time).  The type and value of a GVariant instance
can never change other than by the GVariant itself being
destroyed.  A GVariant cannot contain a pointer.

GVariant is reference counted using C<.ref()> and
C<.unref()>.  GVariant also has floating reference counts --
see C<.ref-sink()>.

GVariant is completely threadsafe.  A GVariant instance can be
concurrently accessed in any way from any number of threads without
problems.

GVariant is heavily optimised for dealing with data in serialized
form.  It works particularly well with data located in memory-mapped
files.  It can perform nearly all deserialization operations in a
small constant time, usually touching only a single memory page.
Serialized GVariant data can also be sent over the network.

GVariant is largely compatible with D-Bus.  Almost all types of
GVariant instances can be sent over D-Bus.  See GVariantType for
exceptions.  (However, GVariant's serialization format is not the same
as the serialization format of a D-Bus message body: use GDBusMessage,
in the gio library, for those.)

For space-efficiency, the GVariant serialization format does not
automatically include the variant's length, type or endianness,
which must either be implied from context (such as knowledge that a
particular file format always contains a little-endian
%G_VARIANT_TYPE_VARIANT which occupies the whole length of the file)
or supplied out-of-band (for instance, a length, type and/or endianness
indicator could be placed at the beginning of a file, network message
or network stream).

A GVariant's size is limited mainly by any lower level operating
system constraints, such as the number of bits in #gsize.  For
example, it is reasonable to have a 2GB file mapped into memory
with GMappedFile, and call C<.new-from-data()> on it.

For convenience to C programmers, GVariant features powerful
varargs-based value construction and destruction.  This feature is
designed to be embedded in other libraries.

There is a Python-inspired text language for describing GVariant
values.  GVariant includes a printer for this language and a parser
with type inferencing.

## Memory Use

GVariant tries to be quite efficient with respect to memory use.
This section gives a rough idea of how much memory is used by the
current implementation.  The information here is subject to change
in the future.

The memory allocated by GVariant can be grouped into 4 broad
purposes: memory for serialized data, memory for the type
information cache, buffer management memory and memory for the
GVariant structure itself.

## Serialized Data Memory

This is the memory that is used for storing GVariant data in
serialized form.  This is what would be sent over the network or
what would end up on disk, not counting any indicator of the
endianness, or of the length or type of the top-level variant.

The amount of memory required to store a boolean is 1 byte. 16,
32 and 64 bit integers and double precision floating point numbers
use their "natural" size.  Strings (including object path and
signature strings) are stored with a nul terminator, and as such
use the length of the string plus 1 byte.

Maybe types use no space at all to represent the null value and
use the same amount of space (sometimes plus one byte) as the
equivalent non-maybe-typed value to represent the non-null case.

Arrays use the amount of space required to store each of their
members, concatenated.  Additionally, if the items stored in an
array are not of a fixed-size (ie: strings, other arrays, etc)
then an additional framing offset is stored for each item.  The
size of this offset is either 1, 2 or 4 bytes depending on the
overall size of the container.  Additionally, extra padding bytes
are added as required for alignment of child values.

Tuples (including dictionary entries) use the amount of space
required to store each of their members, concatenated, plus one
framing offset (as per arrays) for each non-fixed-sized item in
the tuple, except for the last one.  Additionally, extra padding
bytes are added as required for alignment of child values.

Variants use the same amount of space as the item inside of the
variant, plus 1 byte, plus the length of the type string for the
item inside the variant.

As an example, consider a dictionary mapping strings to variants.
In the case that the dictionary is empty, 0 bytes are required for
the serialization.

If we add an item "width" that maps to the int32 value of 500 then
we will use 4 byte to store the int32 (so 6 for the variant
containing it) and 6 bytes for the string.  The variant must be
aligned to 8 after the 6 bytes of the string, so that's 2 extra
bytes.  6 (string) + 2 (padding) + 6 (variant) is 14 bytes used
for the dictionary entry.  An additional 1 byte is added to the
array as a framing offset making a total of 15 bytes.

If we add another entry, "title" that maps to a nullable string
that happens to have a value of null, then we use 0 bytes for the
null value (and 3 bytes for the variant to contain it along with
its type string) plus 6 bytes for the string.  Again, we need 2
padding bytes.  That makes a total of 6 + 2 + 3 = 11 bytes.

We now require extra padding between the two items in the array.
After the 14 bytes of the first item, that's 2 bytes required.
We now require 2 framing offsets for an extra two
bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the entire two-item
dictionary.

## Type Information Cache

For each GVariant type that currently exists in the program a type
information structure is kept in the type information cache.  The
type information structure is required for rapid deserialization.

Continuing with the above example, if a GVariant exists with the
type "a{sv}" then a type information struct will exist for
"a{sv}", "{sv}", "s", and "v".  Multiple uses of the same type
will share the same type information.  Additionally, all
single-digit types are stored in read-only static memory and do
not contribute to the writable memory footprint of a program using
GVariant.

Aside from the type information structures stored in read-only
memory, there are two forms of type information.  One is used for
container types where there is a single element type: arrays and
maybe types.  The other is used for container types where there
are multiple element types: tuples and dictionary entries.

Array type info structures are 6 * sizeof (void *), plus the
memory required to store the type string itself.  This means that
on 32-bit systems, the cache entry for "a{sv}" would require 30
bytes of memory (plus malloc overhead).

Tuple type info structures are 6 * sizeof (void *), plus 4 *
sizeof (void *) for each item in the tuple, plus the memory
required to store the type string itself.  A 2-item tuple, for
example, would have a type information structure that consumed
writable memory in the size of 14 * sizeof (void *) (plus type
string)  This means that on 32-bit systems, the cache entry for
"{sv}" would require 61 bytes of memory (plus malloc overhead).

This means that in total, for our "a{sv}" example, 91 bytes of
type information would be allocated.

The type information cache, additionally, uses a GHashTable to
store and look up the cached items and stores a pointer to this
hash table in static storage.  The hash table is freed when there
are zero items in the type cache.

Although these sizes may seem large it is important to remember
that a program will probably only have a very small number of
different types of values in it and that only one type information
structure is required for many different values of the same type.

## Buffer Management Memory

GVariant uses an internal buffer management structure to deal
with the various different possible sources of serialized data
that it uses.  The buffer is responsible for ensuring that the
correct call is made when the data is no longer in use by
GVariant.  This may involve a g_free() or a g_slice_free() or
even g_mapped_file_unref().

One buffer management structure is used for each chunk of
serialized data.  The size of the buffer management structure
is 4 * (void *).  On 32-bit systems, that's 16 bytes.

## GVariant structure

The size of a GVariant structure is 6 * (void *).  On 32-bit
systems, that's 24 bytes.

GVariant structures only exist if they are explicitly created
with API calls.  For example, if a GVariant is constructed out of
serialized data for the example given above (with the dictionary)
then although there are 9 individual values that comprise the
entire dictionary (two keys, two values, two variants containing
the values, two dictionary entries, plus the dictionary itself),
only 1 GVariant instance exists -- the one referring to the
dictionary.

If calls are made to start accessing the other values then
GVariant instances will exist for those values only for as long
as they are in use (ie: until you call C<.unref()>).  The
type information is shared.  The serialized data and the buffer
management structure for that serialized data is shared by the
child.

## Summary

To put the entire example together, for our dictionary mapping
strings to variants (with two entries, as given above), we are
using 91 bytes of memory for type information, 29 bytes of memory
for the serialized data, 16 bytes for buffer management and 24
bytes for the GVariant instance, or a total of 160 bytes, plus
malloc overhead.  If we were to use C<.get-child-value()> to
access the two dictionary entries, we would use an additional 48
bytes.  If we were to have other dictionaries of the same type, we
would use more memory for the serialized data and buffer
management for those dictionaries, but the type information would
be shared.
=begin comment
=head2 Uml Diagram
![](plantuml/….svg)
=end comment

=begin comment
=head2 Example
  … text …
  … example code …
=end comment

=end pod

#-------------------------------------------------------------------------------
#--[Class Initialization]-------------------------------------------------------
#-------------------------------------------------------------------------------

=begin pod
=head1 Class initialization

=head2 new

=head3 :native-object

Create an object using a native object from elsewhere. See also B<Gnome::N::TopLevelSupportClass>.

  multi method new ( N-Object :$native-object! )


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-variant

Creates a new GVariant instance.

Think of this function as an analogue to g_strdup_printf().

The type of the created instance and the arguments that are expected by this function are determined by C<$format_string>. See the section on GVariant format strings. Please note that the syntax of the format string is very likely to be extended in the future.

The first character of the format string must not be '*' '?' '@' or
'r'; in essence, a new GVariant must always be constructed by this function (and not merely passed through it unmodified).

Note that the arguments must be of the correct width for their types specified in C<$format_string>. This can be achieved by casting them. See the GVariant varargs documentation.

=begin comment

MyFlags some_flags = FLAG_ONE | FLAG_TWO;
const gchar *some_strings[] = { "a", "b", "c", NULL };
GVariant *new_variant;

new_variant = g_variant_new ("(t^as)",
 // This cast is required.
 (guint64) some_flags,
 some_strings);
=end comment


=begin code
method new-variant ( Str $format-string, … --> Gnome::Glib::Variant)
=end code

=item $format-string; a GVariant format string.
=item …; arguments, as per C<$format_string>. Note that each argument must be specified as a type followed by its value!

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-array

Creates a new GVariant array from C<$children>.
 C<$child_type> must be non-C<Nil> if C<$n_children> is zero. Otherwise, the child type is determined by inspecting the first element of the C<$children> array. If C<$child_type> is non-C<Nil> then it must be a definite type.

The items of the array are taken from the C<$children> array. No entry in the C<$children> array may be C<Nil>.

All items in the array must have the same type, which must be the same as C<$child_type>, if given.

If the C<$children> are floating references (see C<.ref-sink()>), the new instance takes ownership of them as if via C<.ref-sink()>.

=begin code
method new-array ( CArray[N-VariantType] $child-type, CArray[N-Variant] $children, Int() $n-children --> Gnome::Glib::Variant)
=end code

=item $child-type; the element type of the new array.
=item $children; an array of
 GVariant pointers, the children.
=item $n-children; the length of C<$children>.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-boolean

Creates a new boolean GVariant instance -- either C<True> or C<False>.

=begin code
method new-boolean ( Bool() $value --> Gnome::Glib::Variant)
=end code

=item $value; a C<gboolean> value.


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-byte

Creates a new byte GVariant instance.

=begin code
method new-byte ( UInt() $value --> Gnome::Glib::Variant)
=end code

=item $value; a C<guint8> value.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-bytestring

Creates an array-of-bytes GVariant with the contents of C<$string>.
This function is just like C<.new-string()> except that the string need not be valid UTF-8.

The nul terminator character at the end of the string is stored in the array.

=begin code
method new-bytestring ( Str $string --> Gnome::Glib::Variant)
=end code

=item $string; a normal
 nul-terminated string in no particular encoding.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-bytestring-array

Constructs an array of bytestring GVariant from the given array of strings.

If C<$length> is -1 then C<$strv> is C<Nil>-terminated.

=begin code
method new-bytestring-array (
  Array[Str] $strv, Int() $length
  --> Gnome::Glib::Variant
)
=end code

=item $strv; an array of strings.
=item $length; the length of C<$strv>, or -1.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-dict-entry

Creates a new dictionary entry GVariant. C<$key> and C<$value> must be non-C<Nil>. C<$key> must be a value of a basic type (ie: not a container).

If the C<$key> or C<$value> are floating references (see C<.ref-sink()>),
the new instance takes ownership of them as if via C<.ref-sink()>.

=begin code
method new-dict-entry (
  CArray[N-Variant] $key, CArray[N-Variant] $value
  --> Gnome::Glib::Variant
)
=end code

=item $key; a basic GVariant, the key.
=item $value; a GVariant, the value.


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-double

Creates a new double GVariant instance.

=begin code
method new-double ( Num() $value --> Gnome::Glib::Variant)
=end code

=item $value; a C<gdouble> floating point value.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-fixed-array

Constructs a new array GVariant instance, where the elements are of C<$element_type> type.
 C<$elements> must be an array with fixed-sized elements. Numeric types are fixed-size as are tuples containing only other fixed-sized types.
 C<$element_size> must be the size of a single element in the array.
For example, if calling this function for an array of 32-bit integers,
you might say sizeof(gint32). This value isn't used except for the purpose of a double-check that the form of the serialized data matches the caller's expectation.
 C<$n_elements> must be the length of the C<$elements> array.

=begin code
method new-fixed-array (
  CArray[N-VariantType] $element-type,
  gpointer $elements, Int() $n-elements,
  Int() $element-size
  --> Gnome::Glib::Variant
)
=end code

=item $element-type; the GVariantType of each element.
=item $elements; a pointer to the fixed array of contiguous elements.
=item $n-elements; the number of elements.
=item $element-size; the size of each element.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-from-bytes

Constructs a new serialized-mode GVariant instance. This is the inner interface for creation of new serialized values that gets called from various functions in gvariant.c.

A reference is taken on C<$bytes>.

The data in C<$bytes> must be aligned appropriately for the C<$type> being loaded.
Otherwise this function will internally create a copy of the memory (since GLib 2.60) or (in older versions) fail and exit the process.

=begin code
method new-from-bytes (
  CArray[N-VariantType] $type,
  CArray[N-Bytes] $bytes, Bool() $trusted
  --> Gnome::Glib::Variant
)
=end code

=item $type; a GVariantType.
=item $bytes; a GBytes.
=item $trusted; if the contents of C<$bytes> are trusted.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-from-data

Creates a new GVariant instance from serialized data.
 C<$type> is the type of GVariant instance that will be constructed.
The interpretation of C<$data> depends on knowing the type.
 C<$data> is not modified by this function and must remain valid with an unchanging value until such a time as C<$notify> is called with C<$user_data>. If the contents of C<$data> change before that time then the result is undefined.

If C<$data> is trusted to be serialized data in normal form then C<$trusted> should be C<True>. This applies to serialized data created within this process or read from a trusted location on the disk (such as a file installed in /usr/lib alongside your application). You should set trusted to C<False> if C<$data> is read from the network, a file in the user's home directory, etc.

If C<$data> was not stored in this machine's native endianness, any multi-byte numeric values in the returned variant will also be in non-native endianness. C<.byteswap()> can be used to recover the original values.
 C<$notify> will be called with C<$user_data> when C<$data> is no longer needed. The exact time of this call is unspecified and might even be before this function returns.

Note: C<$data> must be backed by memory that is aligned appropriately for the C<$type> being loaded. Otherwise this function will internally create a copy of the memory (since GLib 2.60) or (in older versions) fail and exit the process.

=begin code
method new-from-data (
  CArray[N-VariantType] $type, gpointer $data,
  Int() $size, Bool() $trusted, &notify,
  gpointer $user-data
  --> Gnome::Glib::Variant
)
=end code

=item $type; a definite GVariantType.
=item $data; the serialized data.
=item $size; the size of C<$data>.
=item $trusted; C<True> if C<$data> is definitely in normal form.
=item &notify; function to call when C<$data> is no longer needed. Tthe function must be specified with following signature; C<:( gpointer $data )>.
=item $user-data; data for C<$notify>.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-handle

Creates a new handle GVariant instance.

By convention, handles are indexes into an array of file descriptors that are sent alongside a D-Bus message. If you're not interacting with D-Bus, you probably don't need them.

=begin code
method new-handle ( Int() $value --> Gnome::Glib::Variant)
=end code

=item $value; a C<gint32> value.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-int16

Creates a new int16 GVariant instance.

=begin code
method new-int16 ( Int() $value --> Gnome::Glib::Variant)
=end code

=item $value; a C<gint16> value.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-int32

Creates a new int32 GVariant instance.

=begin code
method new-int32 ( Int() $value --> Gnome::Glib::Variant)
=end code

=item $value; a C<gint32> value.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-int64

Creates a new int64 GVariant instance.

=begin code
method new-int64 ( Int() $value --> Gnome::Glib::Variant)
=end code

=item $value; a C<gint64> value.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-maybe

Depending on if C<$child> is C<Nil>, either wraps C<$child> inside of a maybe container or creates a Nothing instance for the given C<$type>.

At least one of C<$child_type> and C<$child> must be non-C<Nil>.
If C<$child_type> is non-C<Nil> then it must be a definite type.
If they are both non-C<Nil> then C<$child_type> must be the type of C<$child>.

If C<$child> is a floating reference (see C<.ref-sink()>), the new instance takes ownership of C<$child>.

=begin code
method new-maybe (
  CArray[N-VariantType] $child-type,
  CArray[N-Variant] $child
  --> Gnome::Glib::Variant
)
=end code

=item $child-type; the GVariantType of the child, or C<Nil>.
=item $child; the child value, or C<Nil>.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-object-path

Creates a D-Bus object path GVariant with the contents of C<$string>. C<$string> must be a valid D-Bus object path. Use C<.is-object-path()> if you're not sure.

=begin code
method new-object-path ( Str $object-path --> Gnome::Glib::Variant)
=end code

=item $object-path; a normal C nul-terminated string.

=end pod

#`{{
#-------------------------------------------------------------------------------
=begin pod
=head2 new-objv

Constructs an array of object paths GVariant from the given array of strings.

Each string must be a valid GVariant object path; see C<.is-object-path()>.

If C<$length> is -1 then C<$strv> is C<Nil>-terminated.

=begin code
method new-objv ( Array[Str] $strv, Int() $length --> Gnome::Glib::Variant)
=end code

=item $strv; an array of strings.
=item $length; the length of C<$strv>, or -1.

=end pod
}}

#-------------------------------------------------------------------------------
=begin pod
=head2 new-parsed

Parses C<$format> and returns the result.
 C<$format> must be a text format GVariant with one extension: at any point that a value may appear in the text, a '%' character followed by a GVariant format string (as per C<.new-variant()>) may appear. In that case, the same arguments are collected from the argument list as C<.new-variant()> would have collected.

Note that the arguments must be of the correct width for their types specified in C<$format>. This can be achieved by casting them. See the GVariant varargs documentation.

=begin comment
Consider this simple example:

 g_variant_new_parsed ("[('one', 1), ('two', %i), (%s, 3)]", 2, "three");
=end comment

=begin comment
In the example, the variable argument parameters are collected and filled in as if they were part of the original string to produce the result of

[('one', 1), ('two', 2), ('three', 3)]
=end comment

This function is intended only to be used with C<$format> as a string literal. Any parse error is fatal to the calling process. If you want to parse data from untrusted sources, use C<.parse()>.

You may not use this function to return, unmodified, a single GVariant pointer from the argument list. ie: C<$format> may not solely be anything along the lines of "%*", "%?", "\%r", or anything starting with "%@".

=begin code
method new-parsed ( Str $format, … --> Gnome::Glib::Variant)
=end code

=item $format; a text format GVariant.
=item …; arguments as per C<$format>. Note that each argument must be specified as a type followed by its value!

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-parsed-va

Parses C<$format> and returns the result.

This is the version of C<.new-parsed()> intended to be used from libraries.

The return value will be floating if it was a newly created GVariant instance. In the case that C<$format> simply specified the collection of a GVariant pointer (eg: C<$format> was "%*") then the collected GVariant pointer will be returned unmodified, without adding any additional references.

Note that the arguments in C<$app> must be of the correct width for their types specified in C<$format> when collected into the #va_list. See the GVariant varargs documentation.

In order to behave correctly in all cases it is necessary for the calling function to C<.ref-sink()> the return result before returning control to the user that originally provided the pointer.
At this point, the caller will have their own full reference to the result. This can also be done by adding the result to a container,
or by passing it to another C<.new-variant()> call.

=begin code
method new-parsed-va ( Str $format, … --> Gnome::Glib::Variant)
=end code

=item $format; a text format GVariant.
=item app; a pointer to a C<va_list>. Note that each argument must be specified as a type followed by its value!

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-printf

Creates a string-type GVariant using printf formatting.

This is similar to calling g_strdup_printf() and then C<.new-string()> but it saves a temporary variable and an unnecessary copy.

=begin code
method new-printf ( Str $format-string, … --> Gnome::Glib::Variant)
=end code

=item $format-string; a printf-style format string.
=item …; arguments for C<$format_string>. Note that each argument must be specified as a type followed by its value!

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-signature

Creates a D-Bus type signature GVariant with the contents of C<$string>. C<$string> must be a valid D-Bus type signature. Use C<.is-signature()> if you're not sure.

=begin code
method new-signature ( Str $signature --> Gnome::Glib::Variant)
=end code

=item $signature; a normal C nul-terminated string.


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-string

Creates a string GVariant with the contents of C<$string>.
 C<$string> must be valid UTF-8, and must not be C<Nil>. To encode potentially-C<Nil> strings, use C<.new-variant()> with `ms` as the format string.

=begin code
method new-string ( Str $string --> Gnome::Glib::Variant)
=end code

=item $string; a normal UTF-8 nul-terminated string.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-strv

Constructs an array of strings GVariant from the given array of strings.

If C<$length> is -1 then C<$strv> is C<Nil>-terminated.

=begin code
method new-strv ( Array[Str] $strv, Int() $length --> Gnome::Glib::Variant)
=end code

=item $strv; an array of strings.
=item $length; the length of C<$strv>, or -1.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-take-string

Creates a string GVariant with the contents of C<$string>.
 C<$string> must be valid UTF-8, and must not be C<Nil>. To encode potentially-C<Nil> strings, use this with C<.new-maybe()>.

This function consumes C<$string>. g_free() will be called on C<$string>
when it is no longer required.

You must not modify or access C<$string> in any other way after passing it to this function. It is even possible that C<$string> is immediately freed.

=begin code
method new-take-string ( Str $string --> Gnome::Glib::Variant)
=end code

=item $string; a normal UTF-8 nul-terminated string.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-tuple

Creates a new tuple GVariant out of the items in C<$children>. The type is determined from the types of C<$children>. No entry in the C<$children> array may be C<Nil>.

If C<$n_children> is 0 then the unit tuple is constructed.

If the C<$children> are floating references (see C<.ref-sink()>), the new instance takes ownership of them as if via C<.ref-sink()>.

=begin code
method new-tuple (
  CArray[N-Variant] $children, Int() $n-children
  --> Gnome::Glib::Variant
)
=end code

=item $children; the items to make the tuple out of.
=item $n-children; the length of C<$children>.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-uint16

Creates a new uint16 GVariant instance.

=begin code
method new-uint16 ( UInt() $value --> Gnome::Glib::Variant)
=end code

=item $value; a C<guint16> value.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-uint32

Creates a new uint32 GVariant instance.

=begin code
method new-uint32 ( UInt() $value --> Gnome::Glib::Variant)
=end code

=item $value; a C<guint32> value.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-uint64

Creates a new uint64 GVariant instance.

=begin code
method new-uint64 ( UInt() $value --> Gnome::Glib::Variant)
=end code

=item $value; a C<guint64> value.

=end pod

#`{{
#-------------------------------------------------------------------------------
=begin pod
=head2 new-va

This function is intended to be used by libraries based on GVariant that want to provide C<.new-variant()>-like functionality to their users.

The API is more general than C<.new-variant()> to allow a wider range of possible uses.
 C<$format_string> must still point to a valid format string, but it only needs to be nul-terminated if C<$endptr> is C<Nil>. If C<$endptr> is non-C<Nil> then it is updated to point to the first character past the end of the format string.
 C<$app> is a pointer to a #va_list. The arguments, according to C<$format_string>, are collected from this #va_list and the list is left pointing to the argument following the last.

Note that the arguments in C<$app> must be of the correct width for their types specified in C<$format_string> when collected into the #va_list.
See the GVariant varargs documentation.

These two generalisations allow mixing of multiple calls to C<.new-va()> and C<.get-va()> within a single actual varargs call by the user.

The return value will be floating if it was a newly created GVariant instance (for example, if the format string was "(ii)"). In the case that the format_string was '*', '?', 'r', or a format starting with
'@' then the collected GVariant pointer will be returned unmodified,
without adding any additional references.

In order to behave correctly in all cases it is necessary for the calling function to C<.ref-sink()> the return result before returning control to the user that originally provided the pointer.
At this point, the caller will have their own full reference to the result. This can also be done by adding the result to a container,
or by passing it to another C<.new-variant()> call.

=begin code
method new-va (
  Str $format-string, Array[Str] $endptr, … --> Gnome::Glib::Variant
)
=end code

=item $format-string; a string that is prefixed with a format string.
=item $endptr; location to store the end pointer,
 or C<Nil>.
=item app; a pointer to a C<va_list>. Note that each argument must be specified as a type followed by its value!

=end pod
}}

#-------------------------------------------------------------------------------
=begin pod
=head2 new-variant-with-variant

Boxes C<$value>. The result is a GVariant instance representing a variant containing the original value.

If C<$child> is a floating reference (see C<.ref-sink()>), the new instance takes ownership of C<$child>.

=begin code
method new-variant-with-variant (
  CArray[N-Variant] $value --> Gnome::Glib::Variant
)
=end code

=item $value; a GVariant instance.

=end pod

#-------------------------------------------------------------------------------
#--[Methods]--------------------------------------------------------------------
#-------------------------------------------------------------------------------

=begin pod
=head1 Methods
=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 byteswap

Performs a byteswapping operation on the contents of C<$value>. The result is that all multi-byte numeric data contained in C<$value> is byteswapped. That includes 16, 32, and 64bit signed and unsigned integers as well as file handles and double precision floating point values.

This function is an identity mapping on any value that does not contain multi-byte numeric data. That include strings, booleans,
bytes and containers containing only these things (recursively).

The returned value is always in normal form and is marked as trusted.

=begin code
method byteswap (--> CArray[N-Variant] )
=end code


Return value; the byteswapped form of C<$value>. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 check-format-string

Checks if calling C<.get()> with C<$format_string> on C<$value> would be valid from a type-compatibility standpoint. C<$format_string> is assumed to be a valid format string (from a syntactic standpoint).

If C<$copy_only> is C<True> then this function additionally checks that it would be safe to call C<.unref()> on C<$value> immediately after the call to C<.get()> without invalidating the result. This is only possible if deep copies are made (ie: there are no pointers to the data inside of the soon-to-be-freed GVariant instance). If this check fails then a g_critical() is printed and C<False> is returned.

This function is meant to be used by functions that wish to provide varargs accessors to GVariant values of uncertain values (eg:
C<.lookup()> or g_menu_model_get_item_attribute()).

=begin code
method check-format-string (
  Str $format-string, Bool() $copy-only --> Bool
)
=end code

=item $format-string; a valid GVariant format string.
=item $copy-only; C<True> to ensure the format string makes deep copies.

Return value; C<True> if C<$format_string> is safe to use. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 classify

Classifies C<$value> according to its top-level type.

=begin code
method classify ( )
=end code


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 compare

Compares C<$one> and C<$two>.

The types of C<$one> and C<$two> are #gconstpointer only to allow use of this function with GTree, GPtrArray, etc. They must each be a GVariant.

Comparison is only defined for basic types (ie: booleans, numbers,
strings). For booleans, C<False> is less than C<True>. Numbers are ordered in the usual way. Strings are in ASCII lexographical order.

It is a programmer error to attempt to compare container values or two values that have types that are not exactly equal. For example,
you cannot compare a 32-bit signed integer with a 32-bit unsigned integer. Also note that this function is not particularly well-behaved when it comes to comparison of doubles; in particular,
the handling of incomparable values (ie: NaN) is undefined.

If you only require an equality comparison, C<.equal()> is more general.

=begin code
method compare ( gpointer $two --> Int )
=end code

=item $two; a GVariant instance of the same type.

Return value; negative value if a < b;
 zero if a = b;
 positive value if a > b.. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 dup-bytestring

Similar to C<.get-bytestring()> except that instead of returning a constant string, the string is duplicated.

The return value must be freed using g_free().

=begin code
method dup-bytestring ( Array[gsize] $length --> Str )
=end code

=item $length; (transfer ownership: full) a pointer to a #gsize, to store
 the length (not including the nul terminator).

Return value; 
 a newly allocated string. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 dup-bytestring-array

Gets the contents of an array of array of bytes GVariant. This call makes a deep copy; the return result should be released with g_strfreev().

If C<$length> is non-C<Nil> then the number of elements in the result is stored there. In any case, the resulting array will be C<Nil>-terminated.

For an empty array, C<$length> will be set to 0 and a pointer to a C<Nil> pointer will be returned.

=begin code
method dup-bytestring-array (
  Array[gsize] $length --> Array[Str]
)
=end code

=item $length; (transfer ownership: full) the length of the result, or C<Nil>.

Return value; an array of strings. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 dup-objv

Gets the contents of an array of object paths GVariant. This call makes a deep copy; the return result should be released with g_strfreev().

If C<$length> is non-C<Nil> then the number of elements in the result is stored there. In any case, the resulting array will be C<Nil>-terminated.

For an empty array, C<$length> will be set to 0 and a pointer to a C<Nil> pointer will be returned.

=begin code
method dup-objv ( Array[gsize] $length --> Array[Str] )
=end code

=item $length; (transfer ownership: full) the length of the result, or C<Nil>.

Return value; an array of strings. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 dup-string

Similar to C<.get-string()> except that instead of returning a constant string, the string is duplicated.

The string will always be UTF-8 encoded.

The return value must be freed using g_free().

=begin code
method dup-string ( Array[gsize] $length --> Str )
=end code

=item $length; (transfer ownership: full) a pointer to a #gsize, to store the length.

Return value; a newly allocated string, UTF-8 encoded. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 dup-strv

Gets the contents of an array of strings GVariant. This call makes a deep copy; the return result should be released with g_strfreev().

If C<$length> is non-C<Nil> then the number of elements in the result is stored there. In any case, the resulting array will be C<Nil>-terminated.

For an empty array, C<$length> will be set to 0 and a pointer to a C<Nil> pointer will be returned.

=begin code
method dup-strv ( Array[gsize] $length --> Array[Str] )
=end code

=item $length; (transfer ownership: full) the length of the result, or C<Nil>.

Return value; an array of strings. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 equal

Checks if C<$one> and C<$two> have the same type and value.

The types of C<$one> and C<$two> are #gconstpointer only to allow use of this function with GHashTable. They must each be a GVariant.

=begin code
method equal ( gpointer $two --> Bool )
=end code

=item $two; a GVariant instance.

Return value; C<True> if C<$one> and C<$two> are equal. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get

Deconstructs a GVariant instance.

Think of this function as an analogue to scanf().

The arguments that are expected by this function are entirely determined by C<$format_string>. C<$format_string> also restricts the permissible types of C<$value>. It is an error to give a value with an incompatible type. See the section on GVariant format strings.
Please note that the syntax of the format string is very likely to be extended in the future.
 C<$format_string> determines the C types that are used for unpacking the values and also determines if the values are copied or borrowed,
see the section on GVariant format strings.

=begin code
method get ( Str $format-string, … )
=end code

=item $format-string; a GVariant format string.
=item …; arguments, as per C<$format_string>. Note that each argument must be specified as a type followed by its value!

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-boolean

Returns the boolean value of C<$value>.

It is an error to call this function with a C<$value> of any type other than %G_VARIANT_TYPE_BOOLEAN.

=begin code
method get-boolean (--> Bool )
=end code


Return value; C<True> or C<False>. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-byte

Returns the byte value of C<$value>.

It is an error to call this function with a C<$value> of any type other than %G_VARIANT_TYPE_BYTE.

=begin code
method get-byte (--> UInt )
=end code


Return value; a #guint8. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-bytestring

Returns the string value of a GVariant instance with an array-of-bytes type. The string has no particular encoding.

If the array does not end with a nul terminator character, the empty string is returned. For this reason, you can always trust that a non-C<Nil> nul-terminated string will be returned by this function.

If the array contains a nul terminator character somewhere other than the last byte then the returned string is the string, up to the first such nul character.

C<.get-fixed-array()> should be used instead if the array contains arbitrary data that could not be nul-terminated or could contain nul bytes.

It is an error to call this function with a C<$value> that is not an array of bytes.

The return value remains valid as long as C<$value> exists.

=begin code
method get-bytestring (--> Str )
=end code


Return value; 
 the constant string. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-bytestring-array

Gets the contents of an array of array of bytes GVariant. This call makes a shallow copy; the return result should be released with g_free(), but the individual strings must not be modified.

If C<$length> is non-C<Nil> then the number of elements in the result is stored there. In any case, the resulting array will be C<Nil>-terminated.

For an empty array, C<$length> will be set to 0 and a pointer to a C<Nil> pointer will be returned.

=begin code
method get-bytestring-array (
  Array[gsize] $length --> Array[Str]
)
=end code

=item $length; (transfer ownership: full) the length of the result, or C<Nil>.

Return value; an array of constant strings. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-child

Reads a child item out of a container GVariant instance and deconstructs it according to C<$format_string>. This call is essentially a combination of C<.get-child-value()> and C<.get()>.
 C<$format_string> determines the C types that are used for unpacking the values and also determines if the values are copied or borrowed,
see the section on GVariant format strings.

=begin code
method get-child ( Int() $index, Str $format-string, … )
=end code

=item $index; the index of the child to deconstruct.
=item $format-string; a GVariant format string.
=item …; arguments, as per C<$format_string>. Note that each argument must be specified as a type followed by its value!

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-child-value

Reads a child item out of a container GVariant instance. This includes variants, maybes, arrays, tuples and dictionary entries. It is an error to call this function on any other type of GVariant.

It is an error if C<$index_> is greater than the number of child items in the container. See C<.n-children()>.

The returned value is never floating. You should free it with C<.unref()> when you're done with it.

Note that values borrowed from the returned child are not guaranteed to still be valid after the child is freed even if you still hold a reference to C<$value>, if C<$value> has not been serialized at the time this function is called. To avoid this, you can serialize C<$value> by calling C<.get-data()> and optionally ignoring the return value.

There may be implementation specific restrictions on deeply nested values,
which would result in the unit tuple being returned as the child value,
instead of further nested children. GVariant is guaranteed to handle nesting up to at least 64 levels.

This function is O(1).

=begin code
method get-child-value ( Int() $index --> CArray[N-Variant] )
=end code

=item $index; the index of the child to fetch.

Return value; the child at the specified index. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-data

Returns a pointer to the serialized form of a GVariant instance.
The returned data may not be in fully-normalised form if read from an untrusted source. The returned data must not be freed; it remains valid for as long as C<$value> exists.

If C<$value> is a fixed-sized value that was deserialized from a corrupted serialized container then C<Nil> may be returned. In this case, the proper thing to do is typically to use the appropriate number of nul bytes in place of C<$value>. If C<$value> is not fixed-sized then C<Nil> is never returned.

In the case that C<$value> is already in serialized form, this function is O(1). If the value is not already in serialized form,
serialization occurs implicitly and is approximately O(n) in the size of the result.

To deserialize the data returned by this function, in addition to the serialized data, you must know the type of the GVariant, and (if the machine might be different) the endianness of the machine that stored it. As a result, file formats or network messages that incorporate serialized GVariants must include this information either implicitly (for instance "the file always contains a
%G_VARIANT_TYPE_VARIANT and it is always in little-endian order") or explicitly (by storing the type and/or endianness in addition to the serialized data).

=begin code
method get-data (--> gpointer )
=end code


Return value; the serialized form of C<$value>, or C<Nil>. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-data-as-bytes

Returns a pointer to the serialized form of a GVariant instance.
The semantics of this function are exactly the same as C<.get-data()>, except that the returned GBytes holds a reference to the variant data.

=begin code
method get-data-as-bytes (--> CArray[N-Bytes]  )
=end code


Return value; A new GBytes representing the variant data. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-double

Returns the double precision floating point value of C<$value>.

It is an error to call this function with a C<$value> of any type other than %G_VARIANT_TYPE_DOUBLE.

=begin code
method get-double (--> Num )
=end code


Return value; a #gdouble. 


=end pod

#`{{
#-------------------------------------------------------------------------------
=begin pod
=head2 get-fixed-array

Provides access to the serialized data for an array of fixed-sized items.
 C<$value> must be an array with fixed-sized elements. Numeric types are fixed-size, as are tuples containing only other fixed-sized types.
 C<$element_size> must be the size of a single element in the array,
as given by the section on serialized data memory.

In particular, arrays of these fixed-sized types can be interpreted as an array of the given C type, with C<$element_size> set to the size the appropriate type:

=item G_VARIANT_TYPE_INT16, G_VARIANT_TYPE_INT32, etc.: gint16, gint32, etc.
=item G_VARIANT_TYPE_BOOLEAN: guchar (not gboolean, that's an 32 bit integer!)
=item G_VARIANT_TYPE_BYTE: guint8
=item G_VARIANT_TYPE_HANDLE: guint32
=item G_VARIANT_TYPE_DOUBLE: gdouble

For example, if calling this function for an array of 32-bit integers,
you might say `sizeof(gint32)`. This value isn't used except for the purpose of a double-check that the form of the serialized data matches the caller's expectation.
 C<$n_elements>, which must be > 1, is set equal to the number of items in the array.

=begin code
method get-fixed-array (
  Array[gsize] $n-elements, Int() $element-size
  --> gpointer
)
=end code

=item $n-elements; (transfer ownership: full) a pointer to the location to store the number of items.
=item $element-size; the size of each element.

Return value; a pointer to
 the fixed array. 


=end pod
}}

#-------------------------------------------------------------------------------
=begin pod
=head2 get-handle

Returns the 32-bit signed integer value of C<$value>.

It is an error to call this function with a C<$value> of any type other than %G_VARIANT_TYPE_HANDLE.

By convention, handles are indexes into an array of file descriptors that are sent alongside a D-Bus message. If you're not interacting with D-Bus, you probably don't need them.

=begin code
method get-handle (--> Int )
=end code


Return value; a #gint32. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-int16

Returns the 16-bit signed integer value of C<$value>.

It is an error to call this function with a C<$value> of any type other than %G_VARIANT_TYPE_INT16.

=begin code
method get-int16 (--> Int )
=end code


Return value; a #gint16. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-int32

Returns the 32-bit signed integer value of C<$value>.

It is an error to call this function with a C<$value> of any type other than %G_VARIANT_TYPE_INT32.

=begin code
method get-int32 (--> Int )
=end code


Return value; a #gint32. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-int64

Returns the 64-bit signed integer value of C<$value>.

It is an error to call this function with a C<$value> of any type other than %G_VARIANT_TYPE_INT64.

=begin code
method get-int64 (--> Int )
=end code


Return value; a #gint64. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-maybe

Given a maybe-typed GVariant instance, extract its value. If the value is Nothing, then this function returns C<Nil>.

=begin code
method get-maybe (--> CArray[N-Variant] )
=end code


Return value; the contents of C<$value>, or C<Nil>. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-normal-form

Gets a GVariant instance that has the same value as C<$value> and is trusted to be in normal form.

If C<$value> is already trusted to be in normal form then a new reference to C<$value> is returned.

If C<$value> is not already trusted, then it is scanned to check if it is in normal form. If it is found to be in normal form then it is marked as trusted and a new reference to it is returned.

If C<$value> is found not to be in normal form then a new trusted GVariant is created with the same value as C<$value>.

It makes sense to call this function if you've received GVariant data from untrusted sources and you want to ensure your serialized output is definitely in normal form.

If C<$value> is already in normal form, a new reference will be returned
(which will be floating if C<$value> is floating). If it is not in normal form,
the newly created GVariant will be returned with a single non-floating reference. Typically, C<.take-ref()> should be called on the return value from this function to guarantee ownership of a single non-floating reference to it.

=begin code
method get-normal-form (--> CArray[N-Variant] )
=end code


Return value; a trusted GVariant. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-objv

Gets the contents of an array of object paths GVariant. This call makes a shallow copy; the return result should be released with g_free(), but the individual strings must not be modified.

If C<$length> is non-C<Nil> then the number of elements in the result is stored there. In any case, the resulting array will be C<Nil>-terminated.

For an empty array, C<$length> will be set to 0 and a pointer to a C<Nil> pointer will be returned.

=begin code
method get-objv ( Array[gsize] $length --> Array[Str] )
=end code

=item $length; (transfer ownership: full) the length of the result, or C<Nil>.

Return value; an array of constant strings. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-size

Determines the number of bytes that would be required to store C<$value>
with C<.store()>.

If C<$value> has a fixed-sized type then this function always returned that fixed size.

In the case that C<$value> is already in serialized form or the size has already been calculated (ie: this function has been called before)
then this function is O(1). Otherwise, the size is calculated, an operation which is approximately O(n) in the number of values involved.

=begin code
method get-size (--> Int )
=end code


Return value; the serialized size of C<$value>. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-string

Returns the string value of a GVariant instance with a string type. This includes the types %G_VARIANT_TYPE_STRING,
%G_VARIANT_TYPE_OBJECT_PATH and %G_VARIANT_TYPE_SIGNATURE.

The string will always be UTF-8 encoded, will never be C<Nil>, and will never contain nul bytes.

If C<$length> is non-C<Nil> then the length of the string (in bytes) is returned there. For trusted values, this information is already known. Untrusted values will be validated and, if valid, a strlen() will be performed. If invalid, a default value will be returned — for
%G_VARIANT_TYPE_OBJECT_PATH, this is `"/"`, and for other types it is the empty string.

It is an error to call this function with a C<$value> of any type other than those three.

The return value remains valid as long as C<$value> exists.

=begin code
method get-string ( Array[gsize] $length --> Str )
=end code

=item $length; (transfer ownership: full) a pointer to a #gsize,
 to store the length.

Return value; the constant string, UTF-8 encoded. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-strv

Gets the contents of an array of strings GVariant. This call makes a shallow copy; the return result should be released with g_free(), but the individual strings must not be modified.

If C<$length> is non-C<Nil> then the number of elements in the result is stored there. In any case, the resulting array will be C<Nil>-terminated.

For an empty array, C<$length> will be set to 0 and a pointer to a C<Nil> pointer will be returned.

=begin code
method get-strv ( Array[gsize] $length --> Array[Str] )
=end code

=item $length; (transfer ownership: full) the length of the result, or C<Nil>.

Return value; an array of constant strings. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-type

Determines the type of C<$value>.

The return value is valid for the lifetime of C<$value> and must not be freed.

=begin code
method get-type (--> CArray[N-VariantType] )
=end code


Return value; a GVariantType. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-type-string

Returns the type string of C<$value>. Unlike the result of calling C<.type-peek-string()>, this string is nul-terminated. This string belongs to GVariant and must not be freed.

=begin code
method get-type-string (--> Str )
=end code


Return value; the type string for the type of C<$value>. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-uint16

Returns the 16-bit unsigned integer value of C<$value>.

It is an error to call this function with a C<$value> of any type other than %G_VARIANT_TYPE_UINT16.

=begin code
method get-uint16 (--> UInt )
=end code


Return value; a #guint16. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-uint32

Returns the 32-bit unsigned integer value of C<$value>.

It is an error to call this function with a C<$value> of any type other than %G_VARIANT_TYPE_UINT32.

=begin code
method get-uint32 (--> UInt )
=end code


Return value; a #guint32. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-uint64

Returns the 64-bit unsigned integer value of C<$value>.

It is an error to call this function with a C<$value> of any type other than %G_VARIANT_TYPE_UINT64.

=begin code
method get-uint64 (--> UInt )
=end code


Return value; a #guint64. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-va

This function is intended to be used by libraries based on GVariant that want to provide C<.get()>-like functionality to their users.

The API is more general than C<.get()> to allow a wider range of possible uses.
 C<$format_string> must still point to a valid format string, but it only need to be nul-terminated if C<$endptr> is C<Nil>. If C<$endptr> is non-C<Nil> then it is updated to point to the first character past the end of the format string.
 C<$app> is a pointer to a #va_list. The arguments, according to C<$format_string>, are collected from this #va_list and the list is left pointing to the argument following the last.

These two generalisations allow mixing of multiple calls to C<.new-va()> and C<.get-va()> within a single actual varargs call by the user.
 C<$format_string> determines the C types that are used for unpacking the values and also determines if the values are copied or borrowed,
see the section on GVariant format strings.

=begin code
method get-va ( Str $format-string, Array[Str] $endptr, … )
=end code

=item $format-string; a string that is prefixed with a format string.
=item $endptr; location to store the end pointer,
 or C<Nil>.
=item app; a pointer to a #va_list. Note that each argument must be specified as a type followed by its value!

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-variant

Unboxes C<$value>. The result is the GVariant instance that was contained in C<$value>.

=begin code
method get-variant (--> CArray[N-Variant] )
=end code


Return value; the item contained in the variant. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 hash

Generates a hash value for a GVariant instance.

The output of this function is guaranteed to be the same for a given value only per-process. It may change between different processor architectures or even different versions of GLib. Do not use this function as a basis for building protocols or file formats.

The type of C<$value> is #gconstpointer only to allow use of this function with GHashTable. C<$value> must be a GVariant.

=begin code
method hash (--> UInt )
=end code


Return value; a hash value corresponding to C<$value>. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 is-container

Checks if C<$value> is a container.

=begin code
method is-container (--> Bool )
=end code


Return value; C<True> if C<$value> is a container. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 is-floating

Checks whether C<$value> has a floating reference count.

This function should only ever be used to assert that a given variant is or is not floating, or for debug purposes. To acquire a reference to a variant that might be floating, always use C<.ref-sink()>
or C<.take-ref()>.

See C<.ref-sink()> for more information about floating reference counts.

=begin code
method is-floating (--> Bool )
=end code


Return value; whether C<$value> is floating. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 is-normal-form

Checks if C<$value> is in normal form.

The main reason to do this is to detect if a given chunk of serialized data is in normal form: load the data into a GVariant using C<.new-from-data()> and then use this function to check.

If C<$value> is found to be in normal form then it will be marked as being trusted. If the value was already marked as being trusted then this function will immediately return C<True>.

There may be implementation specific restrictions on deeply nested values.
GVariant is guaranteed to handle nesting up to at least 64 levels.

=begin code
method is-normal-form (--> Bool )
=end code


Return value; C<True> if C<$value> is in normal form. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 is-of-type

Checks if a value has a type matching the provided type.

=begin code
method is-of-type ( CArray[N-VariantType] $type --> Bool )
=end code

=item $type; a GVariantType.

Return value; C<True> if the type of C<$value> matches C<$type>. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 iter-new

Creates a heap-allocated GVariantIter for iterating over the items in C<$value>.

Use C<.iter-free()> to free the return value when you no longer need it.

A reference is taken to C<$value> and will be released only when C<.iter-free()> is called.

=begin code
method iter-new (--> CArray[N-VariantIter]  )
=end code


Return value; a new heap-allocated GVariantIter. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 lookup

Looks up a value in a dictionary GVariant.

This function is a wrapper around C<.lookup-value()> and C<.get()>. In the case that C<Nil> would have been returned,
this function returns C<False>. Otherwise, it unpacks the returned value and returns C<True>.
 C<$format_string> determines the C types that are used for unpacking the values and also determines if the values are copied or borrowed,
see the section on GVariant format strings.

This function is currently implemented with a linear scan. If you plan to do many lookups then GVariantDict may be more efficient.

=begin code
method lookup ( Str $key, Str $format-string, … --> Bool )
=end code

=item $key; the key to look up in the dictionary.
=item $format-string; a GVariant format string.
=item …; the arguments to unpack the value into. Note that each argument must be specified as a type followed by its value!

Return value; C<True> if a value was unpacked. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 lookup-value

Looks up a value in a dictionary GVariant.

This function works with dictionaries of the type a{s*} (and equally well with type a{o*}, but we only further discuss the string case for sake of clarity).

In the event that C<$dictionary> has the type a{sv}, the C<$expected_type>
string specifies what type of value is expected to be inside of the variant. If the value inside the variant has a different type then C<Nil> is returned. In the event that C<$dictionary> has a value type other than v then C<$expected_type> must directly match the value type and it is used to unpack the value directly or an error occurs.

In either case, if C<$key> is not found in C<$dictionary>, C<Nil> is returned.

If the key is found and the value has the correct type, it is returned. If C<$expected_type> was specified then any non-C<Nil> return value will have this type.

This function is currently implemented with a linear scan. If you plan to do many lookups then GVariantDict may be more efficient.

=begin code
method lookup-value (
  Str $key, N-VariantType $expected-type
  --> N-Variant
)
=end code

=item $key; the key to look up in the dictionary.
=item $expected-type; a GVariantType, or C<Nil>.

Return value; the value of the dictionary key, or C<Nil>. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 n-children

Determines the number of children in a container GVariant instance.
This includes variants, maybes, arrays, tuples and dictionary entries. It is an error to call this function on any other type of GVariant.

For variants, the return value is always 1. For values with maybe types, it is always zero or one. For arrays, it is the length of the array. For tuples it is the number of tuple items (which depends only on the type). For dictionary entries, it is always 2

This function is O(1).

=begin code
method n-children (--> Int )
=end code


Return value; the number of children in the container. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 print

Pretty-prints C<$value> in the format understood by C<.parse()>.

The format is described here.

If C<$type_annotate> is C<True>, then type information is included in the output.

=begin code
method print ( Bool() $type-annotate --> Str )
=end code

=item $type-annotate; C<True> if type information should be included in
 the output.

Return value; a newly-allocated string holding the result.. 


=end pod

#`{{
#-------------------------------------------------------------------------------
=begin pod
=head2 print-string

Behaves as C<.print()>, but operates on a GString.

If C<$string> is non-C<Nil> then it is appended to and returned. Else,
a new empty GString is allocated and it is returned.

=begin code
method print-string (
  CArray[N-String]  $string, Bool() $type-annotate --> CArray[N-String]  )
=end code

=item $string; a GString, or C<Nil>.
=item $type-annotate; C<True> if type information should be included in
 the output.

Return value; a GString containing the string. 


=end pod
}}

#-------------------------------------------------------------------------------
=begin pod
=head2 ref

Increases the reference count of C<$value>.

=begin code
method ref (--> CArray[N-Variant] )
=end code


Return value; the same C<$value>. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 ref-sink

GVariant uses a floating reference count system. All functions with names starting with `g_variant_new_` return floating references.

Calling C<.ref-sink()> on a GVariant with a floating reference will convert the floating reference into a full reference. Calling C<.ref-sink()> on a non-floating GVariant results in an additional normal reference being added.

In other words, if the C<$value> is floating, then this call "assumes ownership" of the floating reference, converting it to a normal reference. If the C<$value> is not floating, then this call adds a new normal reference increasing the reference count by one.

All calls that result in a GVariant instance being inserted into a container will call C<.ref-sink()> on the instance. This means that if the value was just created (and has only its floating reference) then the container will assume sole ownership of the value at that point and the caller will not need to unreference it. This makes certain common styles of programming much easier while still maintaining normal refcounting semantics in situations where values are not floating.

=begin code
method ref-sink (--> CArray[N-Variant] )
=end code


Return value; the same C<$value>. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 store

Stores the serialized form of C<$value> at C<$data>. C<$data> should be large enough. See C<.get-size()>.

The stored data is in machine native byte order but may not be in fully-normalised form if read from an untrusted source. See C<.get-normal-form()> for a solution.

As with C<.get-data()>, to be able to deserialize the serialized variant successfully, its type and (if the destination machine might be different) its endianness must also be available.

This function is approximately O(n) in the size of C<$data>.

=begin code
method store ( gpointer $data )
=end code

=item $data; the location to store the serialized data at.

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 take-ref

If C<$value> is floating, sink it. Otherwise, do nothing.

Typically you want to use C<.ref-sink()> in order to automatically do the correct thing with respect to floating or non-floating references, but there is one specific scenario where this function is helpful.

The situation where this function is helpful is when creating an API that allows the user to provide a callback function that returns a GVariant. We certainly want to allow the user the flexibility to return a non-floating reference from this callback (for the case where the value that is being returned already exists).

At the same time, the style of the GVariant API makes it likely that for newly-created GVariant instances, the user can be saved some typing if they are allowed to return a GVariant with a floating reference.

Using this function on the return value of the user's callback allows the user to do whichever is more convenient for them. The caller will always receives exactly one full reference to the value: either the one that was returned in the first place, or a floating reference that has been converted to a full reference.

This function has an odd interaction when combined with C<.ref-sink()> running at the same time in another thread on the same GVariant instance. If C<.ref-sink()> runs first then the result will be that the floating reference is converted to a hard reference. If C<.take-ref()> runs first then the result will be that the floating reference is converted to a hard reference and an additional reference on top of that one is added. It is best to avoid this situation.

=begin code
method take-ref (--> CArray[N-Variant] )
=end code


Return value; the same C<$value>. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 unref

Decreases the reference count of C<$value>. When its reference count drops to 0, the memory used by the variant is freed.

=begin code
method unref ( )
=end code


=end pod

#-------------------------------------------------------------------------------
#--[Functions]------------------------------------------------------------------
#-------------------------------------------------------------------------------

=begin pod
=head1 Functions
=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 is-object-path

Determines if a given string is a valid D-Bus object path. You should ensure that a string is a valid D-Bus object path before passing it to C<.new-object-path()>.

A valid object path starts with `/` followed by zero or more sequences of characters separated by `/` characters. Each sequence must contain only the characters `[A-Z][a-z][0-9]_`. No sequence
(including the one following the final `/` character) may be empty.

=begin code
method is-object-path ( Str $string --> Bool )
=end code

=item $string; a normal C nul-terminated string.

Return value; C<True> if C<$string> is a D-Bus object path. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 is-signature

Determines if a given string is a valid D-Bus type signature. You should ensure that a string is a valid D-Bus type signature before passing it to C<.new-signature()>.

D-Bus type signatures consist of zero or more definite GVariantType strings in sequence.

=begin code
method is-signature ( Str $string --> Bool )
=end code

=item $string; a normal C nul-terminated string.

Return value; C<True> if C<$string> is a D-Bus type signature. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 parse

Parses a GVariant from a text representation.

A single GVariant is parsed from the content of C<$text>.

The format is described here.

The memory at C<$limit> will never be accessed and the parser behaves as if the character at C<$limit> is the nul terminator. This has the effect of bounding C<$text>.

If C<$endptr> is non-C<Nil> then C<$text> is permitted to contain data following the value that this function parses and C<$endptr> will be updated to point to the first character past the end of the text parsed by this function. If C<$endptr> is C<Nil> and there is extra data then an error is returned.

If C<$type> is non-C<Nil> then the value will be parsed to have that type. This may result in additional parse errors (in the case that the parsed value doesn't fit the type) but may also result in fewer errors (in the case that the type would have been ambiguous, such as with empty arrays).

In the event that the parsing is successful, the resulting GVariant is returned. It is never floating, and must be freed with C<.unref()>.

In case of any error, C<Nil> will be returned. If C<$error> is non-C<Nil>
then it will be set to reflect the error that occurred.

Officially, the language understood by the parser is "any string produced by C<.print()>".

There may be implementation specific restrictions on deeply nested values,
which would result in a %G_VARIANT_PARSE_ERROR_RECURSION error. GVariant is guaranteed to handle nesting up to at least 64 levels.

Example;

  my Gnome::Glib::VariantType $varianttype .= new-varianttype('u');
  my Gnome::Glib::Variant $v .= new(
    :native-object(.parse( $varianttype, '10', Str, Pointer))
  );
  note $v.get-uint32;               # 10


=begin code
method parse (
  CArray[N-VariantType] $type, Str $text,
  Pointer[Str] $limit, Pointer[Str] $endptr
  --> N-Variant
  )
=end code

=item $type; a GVariantType, or C<Nil>.
=item $text; a string containing a GVariant in text form.
=item $limit; a pointer to the end of C<$text>, or C<Nil>.
=item $endptr; a location to store the end pointer, or C<Nil>.

Return value; a non-floating reference to a GVariant, or C<Nil>. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 parse-error-print-context

Pretty-prints a message showing the context of a GVariant parse error within the string for which parsing was attempted.

The resulting string is suitable for output to the console or other monospace media where newlines are treated in the usual way.

The message will typically look something like one of the following:

  unterminated string constant:
  (1, 2, 3, 'abc
  ^^^^

or

  unable to find a common type:
  [1, 2, 3, 'str']
  ^ ^^^^^

The format of the message may change in a future version.
 C<$error> must have come from a failed attempt to C<.parse()> and C<$source_str> must be exactly the same string that caused the error.
If C<$source_str> was not nul-terminated when you passed it to C<.parse()> then you must add nul termination before using this function.

=begin code
method parse-error-print-context (
  CArray[N-Error] $error, Str $source-str --> Str
)
=end code

=item $error; a GError from the C<GVariantParseError enumeration> domain.
=item $source-str; the string that was given to the parser.

Return value; the printed message. 


=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 parse-error-quark

No documentation of method.


=begin code
method parse-error-quark (--> UInt )
=end code


Return value; No documentation about its value and use. 


=end pod

