=comment Package: Gio, C-Source: task
use v6.d;

#-------------------------------------------------------------------------------
#--[Class Description]----------------------------------------------------------
#-------------------------------------------------------------------------------

=begin pod
=TITLE Gnome::Gio::Task
=head1 Description

A B<Gnome::Gio::Task> represents and manages a cancellable ‘task’.

=head3 Asynchronous operations

The most common usage of B<Gnome::Gio::Task> is as a B<Gnome::Gio::Task>, to
manage data during an asynchronous operation. You call
C<.newtask()> in the ‘start’ method, followed by
C<.set-task-data()> and the like if you need to keep some
additional data associated with the task, and then pass the
task object around through your asynchronous operation.
Eventually, you will call a method such as
C<.return-pointer()> or C<.return-error()>, which
will save the value you give it and then invoke the task’s callback
function in the thread-default main context (see
C<.push-thread-default()> in class C<Gnome::Gio::Task>)
where it was created (waiting until the next iteration of the main
loop first, if necessary). The caller will pass the B<Gnome::Gio::Task> back to
the operation’s finish function (as a B<Gnome::Gio::Task>), and you can
use C<.propagate-pointer()> or the like to extract the
return value.

Using B<Gnome::Gio::Task> requires the thread-default  B<MainContext>  from when
the B<Gnome::Gio::Task> was constructed to be running at least until the task has
completed and its data has been freed.

If a B<Gnome::Gio::Task> has been constructed and its callback set, it is an error to
not call B<g_task_return_>*()` on it. GLib will warn at runtime if this happens
(since 2.76).

Here is an example for using B<Gnome::Gio::Task> as a B<Gnome::Gio::Task>:
=begin comment
typedef struct {
  CakeFrostingType frosting;
  char *message;
} DecorationData;

static void
decoration_data_free (DecorationData *decoration)
{
  g_free (decoration->message);
  g_slice_free (DecorationData, decoration);
}

static void
baked_cb (Cake     *cake,
          gpointer  user_data)
{
  GTask *task = user_data;
  DecorationData *decoration = g_task_get_task_data (task);
  GError *error = NULL;

  if (cake == NULL)
    {
      g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
                               "Go to the supermarket");
      g_object_unref (task);
      return;
    }

  if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))
    {
      g_object_unref (cake);
      // g_task_return_error() takes ownership of error
      g_task_return_error (task, error);
      g_object_unref (task);
      return;
    }

  g_task_return_pointer (task, cake, g_object_unref);
  g_object_unref (task);
}

void
baker_bake_cake_async (Baker               *self,
                       guint                radius,
                       CakeFlavor           flavor,
                       CakeFrostingType     frosting,
                       const char          *message,
                       GCancellable        *cancellable,
                       GAsyncReadyCallback  callback,
                       gpointer             user_data)
{
  GTask *task;
  DecorationData *decoration;
  Cake  *cake;

  task = g_task_new (self, cancellable, callback, user_data);
  if (radius < 3)
    {
      g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,
                               "%ucm radius cakes are silly",
                               radius);
      g_object_unref (task);
      return;
    }

  cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);
  if (cake != NULL)
    {
      // _baker_get_cached_cake() returns a reffed cake
      g_task_return_pointer (task, cake, g_object_unref);
      g_object_unref (task);
      return;
    }

  decoration = g_slice_new (DecorationData);
  decoration->frosting = frosting;
  decoration->message = g_strdup (message);
  g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);

  _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
}

Cake *
baker_bake_cake_finish (Baker         *self,
                        GAsyncResult  *result,
                        GError       **error)
{
  g_return_val_if_fail (g_task_is_valid (result, self), NULL);

  return g_task_propagate_pointer (G_TASK (result), error);
}

=end comment

=head3 Chained asynchronous operations

B<Gnome::Gio::Task> also tries to simplify asynchronous operations that
internally chain together several smaller asynchronous
operations. C<.get-cancellable()>, C<.get-context()>,
and C<.get-priority()> allow you to get back the task’s
B<Gnome::Gio::Task>,  B<MainContext> , and
[I/O priority](iface.AsyncResult.html#io-priority)
when starting a new subtask, so you don’t have to keep track
of them yourself. C<.attach-source()> simplifies the case
of waiting for a source to fire (automatically using the correct
 B<MainContext>  and priority).

Here is an example for chained asynchronous operations:
=begin comment
typedef struct {
  Cake *cake;
  CakeFrostingType frosting;
  char *message;
} BakingData;

static void
decoration_data_free (BakingData *bd)
{
  if (bd->cake)
    g_object_unref (bd->cake);
  g_free (bd->message);
  g_slice_free (BakingData, bd);
}

static void
decorated_cb (Cake         *cake,
              GAsyncResult *result,
              gpointer      user_data)
{
  GTask *task = user_data;
  GError *error = NULL;

  if (!cake_decorate_finish (cake, result, &error))
    {
      g_object_unref (cake);
      g_task_return_error (task, error);
      g_object_unref (task);
      return;
    }

  // baking_data_free() will drop its ref on the cake, so we have to
  // take another here to give to the caller.
  g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
  g_object_unref (task);
}

static gboolean
decorator_ready (gpointer user_data)
{
  GTask *task = user_data;
  BakingData *bd = g_task_get_task_data (task);

  cake_decorate_async (bd->cake, bd->frosting, bd->message,
                       g_task_get_cancellable (task),
                       decorated_cb, task);

  return G_SOURCE_REMOVE;
}

static void
baked_cb (Cake     *cake,
          gpointer  user_data)
{
  GTask *task = user_data;
  BakingData *bd = g_task_get_task_data (task);
  GError *error = NULL;

  if (cake == NULL)
    {
      g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
                               "Go to the supermarket");
      g_object_unref (task);
      return;
    }

  bd->cake = cake;

  // Bail out now if the user has already cancelled
  if (g_task_return_error_if_cancelled (task))
    {
      g_object_unref (task);
      return;
    }

  if (cake_decorator_available (cake))
    decorator_ready (task);
  else
    {
      GSource *source;

      source = cake_decorator_wait_source_new (cake);
      // Attach @source to @task’s GMainContext and have it call
      // decorator_ready() when it is ready.
      g_task_attach_source (task, source, decorator_ready);
      g_source_unref (source);
    }
}

void
baker_bake_cake_async (Baker               *self,
                       guint                radius,
                       CakeFlavor           flavor,
                       CakeFrostingType     frosting,
                       const char          *message,
                       gint                 priority,
                       GCancellable        *cancellable,
                       GAsyncReadyCallback  callback,
                       gpointer             user_data)
{
  GTask *task;
  BakingData *bd;

  task = g_task_new (self, cancellable, callback, user_data);
  g_task_set_priority (task, priority);

  bd = g_slice_new0 (BakingData);
  bd->frosting = frosting;
  bd->message = g_strdup (message);
  g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);

  _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
}

Cake *
baker_bake_cake_finish (Baker         *self,
                        GAsyncResult  *result,
                        GError       **error)
{
  g_return_val_if_fail (g_task_is_valid (result, self), NULL);

  return g_task_propagate_pointer (G_TASK (result), error);
}

=end comment

=head3 Asynchronous operations from synchronous ones

You can use C<.run-in-thread()> to turn a synchronous
operation into an asynchronous one, by running it in a thread.
When it completes, the result will be dispatched to the thread-default main
context (see C<.push-thread-default()> in class C<Gnome::Gio::Task>) where the B<Gnome::Gio::Task>
was created.

Running a task in a thread:
=begin comment
typedef struct {
  guint radius;
  CakeFlavor flavor;
  CakeFrostingType frosting;
  char *message;
} CakeData;

static void
cake_data_free (CakeData *cake_data)
{
  g_free (cake_data->message);
  g_slice_free (CakeData, cake_data);
}

static void
bake_cake_thread (GTask         *task,
                  gpointer       source_object,
                  gpointer       task_data,
                  GCancellable  *cancellable)
{
  Baker *self = source_object;
  CakeData *cake_data = task_data;
  Cake *cake;
  GError *error = NULL;

  cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
                    cake_data->frosting, cake_data->message,
                    cancellable, &error);
  if (cake)
    g_task_return_pointer (task, cake, g_object_unref);
  else
    g_task_return_error (task, error);
}

void
baker_bake_cake_async (Baker               *self,
                       guint                radius,
                       CakeFlavor           flavor,
                       CakeFrostingType     frosting,
                       const char          *message,
                       GCancellable        *cancellable,
                       GAsyncReadyCallback  callback,
                       gpointer             user_data)
{
  CakeData *cake_data;
  GTask *task;

  cake_data = g_slice_new (CakeData);
  cake_data->radius = radius;
  cake_data->flavor = flavor;
  cake_data->frosting = frosting;
  cake_data->message = g_strdup (message);
  task = g_task_new (self, cancellable, callback, user_data);
  g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
  g_task_run_in_thread (task, bake_cake_thread);
  g_object_unref (task);
}

Cake *
baker_bake_cake_finish (Baker         *self,
                        GAsyncResult  *result,
                        GError       **error)
{
  g_return_val_if_fail (g_task_is_valid (result, self), NULL);

  return g_task_propagate_pointer (G_TASK (result), error);
}

=end comment

=head3 Adding cancellability to uncancellable tasks

Finally, C<.run-in-thread()> and
C<.run-in-thread-sync()> can be used to turn an uncancellable
operation into a cancellable one. If you call
C<.set-return-on-cancel()>, passing C<True>, then if the task’s
B<Gnome::Gio::Task> is cancelled, it will return control back to the
caller immediately, while allowing the task thread to continue running in the
background (and simply discarding its result when it finally does finish).
Provided that the task thread is careful about how it uses
locks and other externally-visible resources, this allows you
to make ‘GLib-friendly’ asynchronous and cancellable
synchronous variants of blocking APIs.

Cancelling a task:
=begin comment
static void
bake_cake_thread (GTask         *task,
                  gpointer       source_object,
                  gpointer       task_data,
                  GCancellable  *cancellable)
{
  Baker *self = source_object;
  CakeData *cake_data = task_data;
  Cake *cake;
  GError *error = NULL;

  cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
                    cake_data->frosting, cake_data->message,
                    &error);
  if (error)
    {
      g_task_return_error (task, error);
      return;
    }

  // If the task has already been cancelled, then we don’t want to add
  // the cake to the cake cache. Likewise, we don’t  want to have the
  // task get cancelled in the middle of updating the cache.
  // g_task_set_return_on_cancel() will return %TRUE here if it managed
  // to disable return-on-cancel, or %FALSE if the task was cancelled
  // before it could.
  if (g_task_set_return_on_cancel (task, FALSE))
    {
      // If the caller cancels at this point, their
      // GAsyncReadyCallback won’t be invoked until we return,
      // so we don’t have to worry that this code will run at
      // the same time as that code does. But if there were
      // other functions that might look at the cake cache,
      // then we’d probably need a GMutex here as well.
      baker_add_cake_to_cache (baker, cake);
      g_task_return_pointer (task, cake, g_object_unref);
    }
}

void
baker_bake_cake_async (Baker               *self,
                       guint                radius,
                       CakeFlavor           flavor,
                       CakeFrostingType     frosting,
                       const char          *message,
                       GCancellable        *cancellable,
                       GAsyncReadyCallback  callback,
                       gpointer             user_data)
{
  CakeData *cake_data;
  GTask *task;

  cake_data = g_slice_new (CakeData);

  ...

  task = g_task_new (self, cancellable, callback, user_data);
  g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
  g_task_set_return_on_cancel (task, TRUE);
  g_task_run_in_thread (task, bake_cake_thread);
}

Cake *
baker_bake_cake_sync (Baker               *self,
                      guint                radius,
                      CakeFlavor           flavor,
                      CakeFrostingType     frosting,
                      const char          *message,
                      GCancellable        *cancellable,
                      GError             **error)
{
  CakeData *cake_data;
  GTask *task;
  Cake *cake;

  cake_data = g_slice_new (CakeData);

  ...

  task = g_task_new (self, cancellable, NULL, NULL);
  g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
  g_task_set_return_on_cancel (task, TRUE);
  g_task_run_in_thread_sync (task, bake_cake_thread);

  cake = g_task_propagate_pointer (task, error);
  g_object_unref (task);
  return cake;
}

=end comment

=head3 Porting from B<Gnome::Gio::Task>

B<Gnome::Gio::Task>’s API attempts to be simpler than B<Gnome::Gio::Task>’s
in several ways:

=item You can save task-specific data with C<.set-task-data()>, and
  retrieve it later with C<.get-task-data()>. This replaces the
  abuse of C<.set-op-res-gpointer()> in class C<Gnome::Gio::SimpleAsyncResult> for the same
  purpose with B<Gnome::Gio::Task>.
=item In addition to the task data, B<Gnome::Gio::Task> also keeps track of the
  [priority](iface.AsyncResult.html#io-priority), B<Gnome::Gio::Task>,
  and  B<MainContext>  associated with the task, so tasks that
  consist of a chain of simpler asynchronous operations will have easy access
  to those values when starting each sub-task.
=item C<.return-error-if-cancelled()> provides simplified
  handling for cancellation. In addition, cancellation
  overrides any other B<Gnome::Gio::Task> return value by default, like
  B<Gnome::Gio::Task> does when
  C<.set-check-cancellable()> in class C<Gnome::Gio::SimpleAsyncResult> is called.
  (You can use C<.set-check-cancellable()> to turn off that
  behavior.) On the other hand, C<.run-in-thread()>
  guarantees that it will always run your
  B<task_func>, even if the task’s B<Gnome::Gio::Task>
  is already cancelled before the task gets a chance to run;
  you can start your B<task_func> with a
  C<.return-error-if-cancelled()> check if you need the
  old behavior.
=item The ‘return’ methods (eg, C<.return-pointer()>)
  automatically cause the task to be ‘completed’ as well, and
  there is no need to worry about the ‘complete’ vs ‘complete in idle’
  distinction. (B<Gnome::Gio::Task> automatically figures out
  whether the task’s callback can be invoked directly, or
  if it needs to be sent to another  B<MainContext> , or delayed
  until the next iteration of the current  B<MainContext> .)
=item The ‘finish’ functions for B<Gnome::Gio::Task> based operations are generally
  much simpler than B<Gnome::Gio::Task> ones, normally consisting
  of only a single call to C<.propagate-pointer()> or the like.
  Since C<.propagate-pointer()> ‘steals’ the return value from
  the B<Gnome::Gio::Task>, it is not necessary to juggle pointers around to
  prevent it from being freed twice.
=item With B<Gnome::Gio::Task>, it was common to call
  C<.propagate-error()> in class C<Gnome::Gio::SimpleAsyncResult> from the
  B<_finish>()` wrapper function, and have
  virtual method implementations only deal with successful
  returns. This behavior is deprecated, because it makes it
  difficult for a subclass to chain to a parent class’s async
  methods. Instead, the wrapper function should just be a
  simple wrapper, and the virtual method should call an
  appropriate B<g_task_propagate_> function.
  Note that wrapper methods can now use
  C<.legacy-propagate-error()> in class C<Gnome::Gio::R-AsyncResult> to do old-style
  B<Gnome::Gio::Task> error-returning behavior, and
  C<.is-tagged()> in class C<Gnome::Gio::R-AsyncResult> to check if a result is tagged as
  having come from the B<_async>()` wrapper
  function (for ‘short-circuit’ results, such as when passing
  B<0> to C<.read-async()> in class C<Gnome::Gio::InputStream>).

=head3 Thread-safety considerations

Due to some infelicities in the API design, there is a
thread-safety concern that users of B<Gnome::Gio::Task> have to be aware of:

If the B<Gnome::Glib::T-lib> thread drops its last reference to the source object
or the task data before the task is finalized, then the finalizers
of these objects may be called on the worker thread.

This is a problem if the finalizers use non-threadsafe API, and
can lead to hard-to-debug crashes. Possible workarounds include:

=item Clear task data in a signal handler for B<notify>::completed`
=item Keep iterating a main context in the main thread and defer
  dropping the reference to the source object to that main
  context when the task is finalized

=head2 Uml Diagram
=for image :src<asset_files/images/plantuml/Task.png> :width<70%> :class<inline>

=begin comment

=head2 Example
# Example use of module Gnome::Gio::Task

=end comment

=end pod

#-------------------------------------------------------------------------------
#--[Class Initialization]-------------------------------------------------------
#-------------------------------------------------------------------------------

=begin pod
=head1 Class initialization

=head2 new

=head3 :native-object

Create an object using a native object from an object of the same type found elsewhere. See also B<Gnome::N::TopLevelSupportClass>.

  multi method new ( N-Object() :$native-object! )

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 new-task

Creates a B<Gnome::Gio::Task> acting on C<$source-object>, which will eventually be
used to invoke C<$callback> in the current thread-default main context.

Call this in the "start" method of your asynchronous method, and
pass the B<Gnome::Gio::Task> around throughout the asynchronous operation. You
can use C<.set-task-data()> to attach task-specific data to the
object, which you can retrieve later via C<.get-task-data()>.

By default, if C<$cancellable> is cancelled, then the return value of
the task will always be C<G_IO_ERROR_CANCELLED>, even if the task had
already completed before the cancellation. This allows for
simplified handling in cases where cancellation may imply that
other objects that the task depends on have been destroyed. If you
do not want this behavior, you can use
C<.set-check-cancellable()> to change it.

=begin code
method new-task ( gpointer $source-object, N-Object() $cancellable, GAsyncReadyCallback &callback, gpointer $callback-data --> Gnome::Gio::Task \)
=end code

=item $source-object; the B<Gnome::GObject::Object> that owns
  this task, or undefined..
=item $cancellable; optional B<Gnome::Gio::Cancellable> object, undefined to ignore..
=item GAsyncReadyCallback &callback; a B<Gnome::Gio::T-iotypes>.. The function must be specified with the following signature; C<:( N-Object $source-object, N-Object $res, gpointer $data )>.
=item $callback-data; user data passed to C<$callback>..

=begin comment

=head2 Example
# Example for new-task

=end comment

=end pod

#-------------------------------------------------------------------------------
#--[Methods]--------------------------------------------------------------------
#-------------------------------------------------------------------------------

=begin pod
=head1 Methods
=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 attach-source

A utility function for dealing with async operations where you need
to wait for a B<Gnome::Glib::N-Source> to trigger. Attaches C<$source> to C<$task>'s
B<Gnome::Glib::N-MainContext> with C<$task>'s [priority](iface.AsyncResult.html#io-priority),
and sets C<$source>'s callback to C<$callback>, with C<$task> as the callback's
B<user_data>.

It will set the C<$source>’s name to the task’s name (as set with
C<.set-name()>), if one has been set on the task and the source doesn’t
yet have a name.

This takes a reference on C<$task> until C<$source> is destroyed.

=begin code
method attach-source ( N-Object $source, GSourceFunc &callback )
=end code

=item $source; the source to attach
=item GSourceFunc &callback; the callback to invoke when C<$source> triggers. The function must be specified with the following signature; C<:( gpointer $user-data )>.

=begin comment

=head2 Example
# Example for attach-source

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-cancellable

Gets C<$task>'s B<Gnome::Gio::Cancellable>

=begin code
method get-cancellable (--> N-Object )
=end code

Return value; C<$task>'s B<Gnome::Gio::Cancellable>. 

=begin comment

=head2 Example
# Example for get-cancellable

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-check-cancellable

Gets C<$task>'s check-cancellable flag. See
C<.set-check-cancellable()> for more details.

=begin code
method get-check-cancellable (--> Bool )
=end code

Return value; No documentation about its value and use. 

=begin comment

=head2 Example
# Example for get-check-cancellable

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-completed

Gets the value of B<Gnome::Gio::Task>:completed. This changes from C<False> to C<True> after
the task’s callback is invoked, and will return C<False> if called from inside
the callback.

=begin code
method get-completed (--> Bool )
=end code

Return value; C<True> if the task has completed, C<False> otherwise.. 

=begin comment

=head2 Example
# Example for get-completed

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-context

Gets the B<Gnome::Glib::N-MainContext> that C<$task> will return its result in (that
is, the context that was the thread-default main context
at the point when C<$task> was created).

This will always return a non-undefined value, even if the task's
context is the default B<Gnome::Glib::N-MainContext>.

=begin code
method get-context (--> N-Object )
=end code

Return value; C<$task>'s B<Gnome::Glib::N-MainContext>. 

=begin comment

=head2 Example
# Example for get-context

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-name

Gets C<$task>’s name. See C<.set-name()>.

=begin code
method get-name (--> Str )
=end code

Return value; C<$task>’s name, or undefined. 

=begin comment

=head2 Example
# Example for get-name

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-priority

Gets C<$task>'s priority

=begin code
method get-priority (--> Int )
=end code

Return value; C<$task>'s priority. 

=begin comment

=head2 Example
# Example for get-priority

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-return-on-cancel

Gets C<$task>'s return-on-cancel flag. See
C<.set-return-on-cancel()> for more details.

=begin code
method get-return-on-cancel (--> Bool )
=end code

Return value; No documentation about its value and use. 

=begin comment

=head2 Example
# Example for get-return-on-cancel

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-source-object

Gets the source object from C<$task>. Like
g_async_result_get_source_object(), but does not ref the object.

=begin code
method get-source-object (--> gpointer )
=end code

Return value; C<$task>'s source object, or undefined. 

=begin comment

=head2 Example
# Example for get-source-object

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-source-tag

Gets C<$task>'s source tag. See C<.set-source-tag()>.

=begin code
method get-source-tag (--> gpointer )
=end code

Return value; C<$task>'s source tag. 

=begin comment

=head2 Example
# Example for get-source-tag

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 get-task-data

Gets C<$task>'s B<task_data>.

=begin code
method get-task-data (--> gpointer )
=end code

Return value; C<$task>'s B<task_data>.. 

=begin comment

=head2 Example
# Example for get-task-data

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 had-error

Tests if C<$task> resulted in an error.

=begin code
method had-error (--> Bool )
=end code

Return value; C<True> if the task resulted in an error, C<False> otherwise.. 

=begin comment

=head2 Example
# Example for had-error

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 propagate-boolean

Gets the result of C<$task> as a #gboolean.

If the task resulted in an error, or was cancelled, then this will
instead return C<False> and set C<$error>.

Since this method transfers ownership of the return value (or
error) to the caller, you may only call it once.

=begin code
method propagate-boolean ( CArray[N-Error] $err --> Bool )
=end code

=item $err; Error object. When defined, an error can be returned when there is one.
Use C<Pointer> when you want to ignore the error.
.

Return value; the task result, or C<False> on error. 

=begin comment

=head2 Example
# Example for propagate-boolean

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 propagate-int

Gets the result of C<$task> as an integer (#gssize).

If the task resulted in an error, or was cancelled, then this will
instead return -1 and set C<$error>.

Since this method transfers ownership of the return value (or
error) to the caller, you may only call it once.

=begin code
method propagate-int ( CArray[N-Error] $err --> Int )
=end code

=item $err; Error object. When defined, an error can be returned when there is one.
Use C<Pointer> when you want to ignore the error.
.

Return value; the task result, or -1 on error. 

=begin comment

=head2 Example
# Example for propagate-int

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 propagate-pointer

Gets the result of C<$task> as a pointer, and transfers ownership
of that value to the caller.

If the task resulted in an error, or was cancelled, then this will
instead return undefined and set C<$error>.

Since this method transfers ownership of the return value (or
error) to the caller, you may only call it once.

=begin code
method propagate-pointer ( CArray[N-Error] $err --> gpointer )
=end code

=item $err; Error object. When defined, an error can be returned when there is one.
Use C<Pointer> when you want to ignore the error.
.

Return value; the task result, or undefined on error. 

=begin comment

=head2 Example
# Example for propagate-pointer

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 propagate-value

Gets the result of C<$task> as a B<Gnome::GObject::N-Value>, and transfers ownership of
that value to the caller. As with C<.return-value()>, this is
a generic low-level method; C<.propagate-pointer()> and the like
will usually be more useful for C code.

If the task resulted in an error, or was cancelled, then this will
instead set C<$error> and return C<False>.

Since this method transfers ownership of the return value (or
error) to the caller, you may only call it once.

=begin code
method propagate-value ( N-Object $value, CArray[N-Error] $err --> Bool )
=end code

=item $value; return location for the B<Gnome::GObject::N-Value>
=item $err; Error object. When defined, an error can be returned when there is one.
Use C<Pointer> when you want to ignore the error.
.

Return value; C<True> if C<$task> succeeded, C<False> on error.. 

=begin comment

=head2 Example
# Example for propagate-value

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 return-boolean

Sets C<$task>'s result to C<$result> and completes the task (see
C<.return-pointer()> for more discussion of exactly what this
means).

=begin code
method return-boolean ( Bool() $result )
=end code

=item $result; the #gboolean result of a task function..

=begin comment

=head2 Example
# Example for return-boolean

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 return-error

Sets C<$task>'s result to C<$error> (which C<$task> assumes ownership of)
and completes the task (see C<.return-pointer()> for more
discussion of exactly what this means).

Note that since the task takes ownership of C<$error>, and since the
task may be completed before returning from C<.return-error()>,
you cannot assume that C<$error> is still valid after calling this.
Call g_error_copy() on the error if you need to keep a local copy
as well.

See also C<.return-new-error()>,
C<.return-new-error-literal()>.

=begin code
method return-error ( N-Object $error )
=end code

=item $error; (transfer ownership: full) the B<Gnome::Glib::N-Error> result of a task function.

=begin comment

=head2 Example
# Example for return-error

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 return-error-if-cancelled

Checks if C<$task>'s B<Gnome::Gio::Cancellable> has been cancelled, and if so, sets C<$task>'s error accordingly and completes the task (see
C<.return-pointer()> for more discussion of exactly what this
means).

=begin code
method return-error-if-cancelled (--> Bool )
=end code

Return value; C<True> if C<$task> has been cancelled, C<False> if not. 

=begin comment

=head2 Example
# Example for return-error-if-cancelled

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 return-int

Sets C<$task>'s result to C<$result> and completes the task (see
C<.return-pointer()> for more discussion of exactly what this
means).

=begin code
method return-int ( Int() $result )
=end code

=item $result; the integer (#gssize) result of a task function..

=begin comment

=head2 Example
# Example for return-int

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 return-new-error
This function is not yet available

Sets C<$task>'s result to a new B<Gnome::Glib::N-Error> created from C<$domain>, C<$code>, C<$format>, and the remaining arguments, and completes the task (see
C<.return-pointer()> for more discussion of exactly what this
means).

See also C<.return-error()>.

=begin code
method return-new-error ( UInt $domain, Int() $code, Str $format, … )
=end code

=item $domain; a B<Gnome::Glib::Task>..
=item $code; an error code..
=item $format; a string with format characters..
=item …; …. Note that each argument must be specified as a type followed by its value!

=begin comment

=head2 Example
# Example for return-new-error

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 return-new-error-literal

Sets C<$task>’s result to a new [type C<$GLib>.Error] created from C<$domain>, C<$code>, C<$message> and completes the task.

See C<.return-pointer()> for more discussion of exactly what
‘completing the task’ means.

See also C<.return-new-error()>.

=begin code
method return-new-error-literal ( UInt $domain, Int() $code, Str $message )
=end code

=item $domain; a B<Gnome::Glib::Task>..
=item $code; an error code..
=item $message; an error message.

=begin comment

=head2 Example
# Example for return-new-error-literal

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 return-pointer

Sets C<$task>'s result to C<$result> and completes the task. If C<$result>
is defined, then C<$result-destroy> will be used to free C<$result> if
the caller does not take ownership of it with
C<.propagate-pointer()>.

"Completes the task" means that for an ordinary asynchronous task
it will either invoke the task's callback, or else queue that
callback to be invoked in the proper B<Gnome::Glib::N-MainContext>, or in the next
iteration of the current B<Gnome::Glib::N-MainContext>. For a task run via
C<.run-in-thread()> or C<.run-in-thread-sync()>, calling this
method will save C<$result> to be returned to the caller later, but
the task will not actually be completed until the B<Gnome::Gio::T-task>
exits.

Note that since the task may be completed before returning from
C<.return-pointer()>, you cannot assume that C<$result> is still
valid after calling this, unless you are still holding another
reference on it.

=begin code
method return-pointer ( gpointer $result, GDestroyNotify &result-destroy )
=end code

=item $result; (transfer ownership: full) the pointer result of a task
    function.
=item GDestroyNotify &result-destroy; a B<Gnome::Glib::T-types> function.. The function must be specified with the following signature; C<:( gpointer $data )>.

=begin comment

=head2 Example
# Example for return-pointer

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 return-prefixed-error
This function is not yet available

Sets C<$task>'s result to C<$error> (which C<$task> assumes ownership of), with
the message prefixed according to C<$format>, and completes the task
(see C<.return-pointer()> for more discussion of exactly what this
means).

Note that since the task takes ownership of C<$error>, and since the
task may be completed before returning from C<.return-prefixed-error()>,
you cannot assume that C<$error> is still valid after calling this.
Call g_error_copy() on the error if you need to keep a local copy
as well.

See also C<.return-error()>, g_prefix_error().

=begin code
method return-prefixed-error ( N-Object $error, Str $format, … )
=end code

=item $error; (transfer ownership: full) the B<Gnome::Glib::N-Error> result of a task function.
=item $format; a string with format characters..
=item …; …. Note that each argument must be specified as a type followed by its value!

=begin comment

=head2 Example
# Example for return-prefixed-error

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 return-value

Sets C<$task>'s result to C<$result> (by copying it) and completes the task.

If C<$result> is undefined then a B<Gnome::GObject::N-Value> of type C<G_TYPE_POINTER>
with a value of undefined will be used for the result.

This is a very generic low-level method intended primarily for use
by language bindings; for C code, C<.return-pointer()> and the
like will normally be much easier to use.

=begin code
method return-value ( N-Object $result )
=end code

=item $result; the B<Gnome::GObject::N-Value> result of
                                     a task function

=begin comment

=head2 Example
# Example for return-value

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 run-in-thread

Runs C<$task-func> in another thread. When C<$task-func> returns, C<$task>'s
B<Gnome::Gio::T-iotypes> will be invoked in C<$task>'s B<Gnome::Glib::N-MainContext>.

This takes a ref on C<$task> until the task completes.

See B<Gnome::Gio::T-task> for more details about how C<$task-func> is handled.

Although GLib currently rate-limits the tasks queued via
C<.run-in-thread()>, you should not assume that it will always
do this. If you have a very large number of tasks to run (several tens of
tasks), but don't want them to all run at once, you should only queue a
limited number of them (around ten) at a time.

Be aware that if your task depends on other tasks to complete, use of this
function could lead to a livelock if the other tasks also use this function
and enough of them (around 10) execute in a dependency chain, as that will
exhaust the thread pool. If this situation is possible, consider using a
separate worker thread or thread pool explicitly, rather than using
C<.run-in-thread()>.

=begin code
method run-in-thread ( GTaskThreadFunc &task-func )
=end code

=item GTaskThreadFunc &task-func; a B<Gnome::Gio::T-task>. The function must be specified with the following signature; C<:( N-Object $task, gpointer $source-object, gpointer $task-data, N-Object $cancellable )>.

=begin comment

=head2 Example
# Example for run-in-thread

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 run-in-thread-sync

Runs C<$task-func> in another thread, and waits for it to return or be
cancelled. You can use C<.propagate-pointer()>, etc, afterward
to get the result of C<$task-func>.

See B<Gnome::Gio::T-task> for more details about how C<$task-func> is handled.

Normally this is used with tasks created with a undefined
B<callback>, but note that even if the task does
have a callback, it will not be invoked when C<$task-func> returns.
B<Gnome::Gio::Task>:completed will be set to C<True> just before this function returns.

Although GLib currently rate-limits the tasks queued via
C<.run-in-thread-sync()>, you should not assume that it will
always do this. If you have a very large number of tasks to run,
but don't want them to all run at once, you should only queue a
limited number of them at a time.

=begin code
method run-in-thread-sync ( GTaskThreadFunc &task-func )
=end code

=item GTaskThreadFunc &task-func; a B<Gnome::Gio::T-task>. The function must be specified with the following signature; C<:( N-Object $task, gpointer $source-object, gpointer $task-data, N-Object $cancellable )>.

=begin comment

=head2 Example
# Example for run-in-thread-sync

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 set-check-cancellable

Sets or clears C<$task>'s check-cancellable flag. If this is C<True>
(the default), then C<.propagate-pointer()>, etc, and
C<.had-error()> will check the task's B<Gnome::Gio::Cancellable> first, and
if it has been cancelled, then they will consider the task to have
returned an "Operation was cancelled" error
(C<G_IO_ERROR_CANCELLED>), regardless of any other error or return
value the task may have had.

If C<$check-cancellable> is C<False>, then the B<Gnome::Gio::Task> will not check the
cancellable itself, and it is up to C<$task>'s owner to do this (eg,
via C<.return-error-if-cancelled()>).

If you are using C<.set-return-on-cancel()> as well, then
you must leave check-cancellable set C<True>.

=begin code
method set-check-cancellable ( Bool() $check-cancellable )
=end code

=item $check-cancellable; whether B<Gnome::Gio::Task> will check the state of
  its B<Gnome::Gio::Cancellable> for you..

=begin comment

=head2 Example
# Example for set-check-cancellable

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 set-name

Sets C<$task>’s name, used in debugging and profiling. The name defaults to
undefined.

The task name should describe in a human readable way what the task does.
For example, ‘Open file’ or ‘Connect to network host’. It is used to set the
name of the B<Gnome::Glib::N-Source> used for idle completion of the task.

This function may only be called before the C<$task> is first used in a thread
other than the one it was constructed in. It is called automatically by
C<.set-source-tag()> if not called already.

=begin code
method set-name ( Str $name )
=end code

=item $name; a human readable name for the task, or undefined to unset it.

=begin comment

=head2 Example
# Example for set-name

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 set-priority

Sets C<$task>'s priority. If you do not call this, it will default to
C<G_PRIORITY_DEFAULT>.

This will affect the priority of B<GSources> created with
C<.attach-source()> and the scheduling of tasks run in threads,
and can also be explicitly retrieved later via
C<.get-priority()>.

=begin code
method set-priority ( Int() $priority )
=end code

=item $priority; the [priority](iface.AsyncResult.html#io-priority) of the request.

=begin comment

=head2 Example
# Example for set-priority

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 set-return-on-cancel

Sets or clears C<$task>'s return-on-cancel flag. This is only
meaningful for tasks run via C<.run-in-thread()> or
C<.run-in-thread-sync()>.

If C<$return-on-cancel> is C<True>, then cancelling C<$task>'s
B<Gnome::Gio::Cancellable> will immediately cause it to return, as though the
task's B<Gnome::Gio::T-task> had called
C<.return-error-if-cancelled()> and then returned.

This allows you to create a cancellable wrapper around an
uninterruptible function. The B<Gnome::Gio::T-task> just needs to be
careful that it does not modify any externally-visible state after
it has been cancelled. To do that, the thread should call
C<.set-return-on-cancel()> again to (atomically) set
return-on-cancel C<False> before making externally-visible changes;
if the task gets cancelled before the return-on-cancel flag could
be changed, C<.set-return-on-cancel()> will indicate this by
returning C<False>.

You can disable and re-enable this flag multiple times if you wish.
If the task's B<Gnome::Gio::Cancellable> is cancelled while return-on-cancel is
C<False>, then calling C<.set-return-on-cancel()> to set it C<True>
again will cause the task to be cancelled at that point.

If the task's B<Gnome::Gio::Cancellable> is already cancelled before you call
C<.run-in-thread()>/C<.run-in-thread-sync()>, then the
B<Gnome::Gio::T-task> will still be run (for consistency), but the task
will also be completed right away.

=begin code
method set-return-on-cancel ( Bool() $return-on-cancel --> Bool )
=end code

=item $return-on-cancel; whether the task returns automatically when
  it is cancelled..

Return value; C<True> if C<$task>'s return-on-cancel flag was changed to
  match C<$return-on-cancel>. C<False> if C<$task> has already been
  cancelled.. 

=begin comment

=head2 Example
# Example for set-return-on-cancel

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 set-source-tag

Sets C<$task>'s source tag.

You can use this to tag a task return
value with a particular pointer (usually a pointer to the function
doing the tagging) and then later check it using
C<.get-source-tag()> (or g_async_result_is_tagged()) in the
task's "finish" function, to figure out if the response came from a
particular place.

A macro wrapper around this function will automatically set the
task’s name to the string form of C<$source-tag> if it’s not already
set, for convenience.

=begin code
method set-source-tag ( gpointer $source-tag )
=end code

=item $source-tag; an opaque pointer indicating the source of this task.

=begin comment

=head2 Example
# Example for set-source-tag

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 set-static-name

Sets C<$task>’s name, used in debugging and profiling.

This is a variant of C<.set-name()> that avoids copying C<$name>.

=begin code
method set-static-name ( Str $name )
=end code

=item $name; a human readable name for the task. Must be a string literal.

=begin comment

=head2 Example
# Example for set-static-name

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 set-task-data

Sets C<$task>'s task data (freeing the existing task data, if any).

=begin code
method set-task-data ( gpointer $task-data, GDestroyNotify &task-data-destroy )
=end code

=item $task-data; task-specific data.
=item GDestroyNotify &task-data-destroy; B<Gnome::Glib::T-types> for C<$task-data>. The function must be specified with the following signature; C<:( gpointer $data )>.

=begin comment

=head2 Example
# Example for set-task-data

=end comment

=end pod

#-------------------------------------------------------------------------------
#--[Functions]------------------------------------------------------------------
#-------------------------------------------------------------------------------

=begin pod
=head1 Functions
=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 is-valid

Checks that C<$result> is a B<Gnome::Gio::Task>, and that C<$source-object> is its
source object (or that C<$source-object> is undefined and C<$result> has no
source object). This can be used in g_return_if_fail() checks.

=begin code
method is-valid ( gpointer $result, gpointer $source-object --> Bool )
=end code

=item $result; A B<Gnome::Gio::R-AsyncResult>.
=item $source-object; the source object
  expected to be associated with the task.

Return value; C<True> if C<$result> and C<$source-object> are valid, C<False>
if not. 

=begin comment

=head2 Example
# Example for is-valid

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 report-error

Creates a B<Gnome::Gio::Task> and then immediately calls C<.return-error()>
on it. Use this in the wrapper function of an asynchronous method
when you want to avoid even calling the virtual method. You can
then use g_async_result_is_tagged() in the finish method wrapper to
check if the result there is tagged as having been created by the
wrapper method, and deal with it appropriately if so.

See also C<.report-new-error()>.

=begin code
method report-error ( gpointer $source-object, GAsyncReadyCallback &callback, gpointer $callback-data, gpointer $source-tag, N-Object $error )
=end code

=item $source-object; the B<Gnome::GObject::Object> that owns
  this task, or undefined..
=item GAsyncReadyCallback &callback; a B<Gnome::Gio::T-iotypes>.. The function must be specified with the following signature; C<:( N-Object $source-object, N-Object $res, gpointer $data )>.
=item $callback-data; user data passed to C<$callback>..
=item $source-tag; an opaque pointer indicating the source of this task.
=item $error; (transfer ownership: full) error to report

=begin comment

=head2 Example
# Example for report-error

=end comment

=end pod

#-------------------------------------------------------------------------------
=begin pod
=head2 report-new-error
This function is not yet available

Creates a B<Gnome::Gio::Task> and then immediately calls
C<.return-new-error()> on it. Use this in the wrapper function
of an asynchronous method when you want to avoid even calling the
virtual method. You can then use g_async_result_is_tagged() in the
finish method wrapper to check if the result there is tagged as
having been created by the wrapper method, and deal with it
appropriately if so.

See also C<.report-error()>.

=begin code
method report-new-error ( gpointer $source-object, GAsyncReadyCallback &callback, gpointer $callback-data, gpointer $source-tag, UInt $domain, Int() $code, Str $format, … )
=end code

=item $source-object; the B<Gnome::GObject::Object> that owns
  this task, or undefined..
=item GAsyncReadyCallback &callback; a B<Gnome::Gio::T-iotypes>.. The function must be specified with the following signature; C<:( N-Object $source-object, N-Object $res, gpointer $data )>.
=item $callback-data; user data passed to C<$callback>..
=item $source-tag; an opaque pointer indicating the source of this task.
=item $domain; a B<Gnome::Glib::Task>..
=item $code; an error code..
=item $format; a string with format characters..
=item …; …. Note that each argument must be specified as a type followed by its value!

=begin comment

=head2 Example
# Example for report-new-error

=end comment

=end pod

