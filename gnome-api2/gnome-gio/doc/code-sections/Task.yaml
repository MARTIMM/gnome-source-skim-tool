---
"____EXAMPLE____000": "=begin comment\n\n=head2 Uml Diagram\n![](plantuml/….svg)\n\n=end comment\n"
"____EXAMPLE____001": "=begin comment\n\n=head2 Example\n# Example use of module Gnome::Gio::Task\n\n=end comment\n"
"____EXAMPLE____002": "=begin comment\n\n=head2 Example\n# Example for new-task\n\n=end comment\n"
"____EXAMPLE____003": "=begin comment\n\n=head2 Example\n# Example for attach-source\n\n=end comment\n"
"____EXAMPLE____004": "=begin comment\n\n=head2 Example\n# Example for get-cancellable\n\n=end comment\n"
"____EXAMPLE____005": "=begin comment\n\n=head2 Example\n# Example for get-check-cancellable\n\n=end comment\n"
"____EXAMPLE____006": "=begin comment\n\n=head2 Example\n# Example for get-completed\n\n=end comment\n"
"____EXAMPLE____007": "=begin comment\n\n=head2 Example\n# Example for get-context\n\n=end comment\n"
"____EXAMPLE____008": "=begin comment\n\n=head2 Example\n# Example for get-name\n\n=end comment\n"
"____EXAMPLE____009": "=begin comment\n\n=head2 Example\n# Example for get-priority\n\n=end comment\n"
"____EXAMPLE____010": "=begin comment\n\n=head2 Example\n# Example for get-return-on-cancel\n\n=end comment\n"
"____EXAMPLE____011": "=begin comment\n\n=head2 Example\n# Example for get-source-object\n\n=end comment\n"
"____EXAMPLE____012": "=begin comment\n\n=head2 Example\n# Example for get-source-tag\n\n=end comment\n"
"____EXAMPLE____013": "=begin comment\n\n=head2 Example\n# Example for get-task-data\n\n=end comment\n"
"____EXAMPLE____014": "=begin comment\n\n=head2 Example\n# Example for had-error\n\n=end comment\n"
"____EXAMPLE____015": "=begin comment\n\n=head2 Example\n# Example for propagate-boolean\n\n=end comment\n"
"____EXAMPLE____016": "=begin comment\n\n=head2 Example\n# Example for propagate-int\n\n=end comment\n"
"____EXAMPLE____017": "=begin comment\n\n=head2 Example\n# Example for propagate-pointer\n\n=end comment\n"
"____EXAMPLE____018": "=begin comment\n\n=head2 Example\n# Example for propagate-value\n\n=end comment\n"
"____EXAMPLE____019": "=begin comment\n\n=head2 Example\n# Example for return-boolean\n\n=end comment\n"
"____EXAMPLE____020": "=begin comment\n\n=head2 Example\n# Example for return-error\n\n=end comment\n"
"____EXAMPLE____021": "=begin comment\n\n=head2 Example\n# Example for return-error-if-cancelled\n\n=end comment\n"
"____EXAMPLE____022": "=begin comment\n\n=head2 Example\n# Example for return-int\n\n=end comment\n"
"____EXAMPLE____023": "=begin comment\n\n=head2 Example\n# Example for return-new-error\n\n=end comment\n"
"____EXAMPLE____024": "=begin comment\n\n=head2 Example\n# Example for return-new-error-literal\n\n=end comment\n"
"____EXAMPLE____025": "=begin comment\n\n=head2 Example\n# Example for return-pointer\n\n=end comment\n"
"____EXAMPLE____026": "=begin comment\n\n=head2 Example\n# Example for return-prefixed-error\n\n=end comment\n"
"____EXAMPLE____027": "=begin comment\n\n=head2 Example\n# Example for return-value\n\n=end comment\n"
"____EXAMPLE____028": "=begin comment\n\n=head2 Example\n# Example for run-in-thread\n\n=end comment\n"
"____EXAMPLE____029": "=begin comment\n\n=head2 Example\n# Example for run-in-thread-sync\n\n=end comment\n"
"____EXAMPLE____030": "=begin comment\n\n=head2 Example\n# Example for set-check-cancellable\n\n=end comment\n"
"____EXAMPLE____031": "=begin comment\n\n=head2 Example\n# Example for set-name\n\n=end comment\n"
"____EXAMPLE____032": "=begin comment\n\n=head2 Example\n# Example for set-priority\n\n=end comment\n"
"____EXAMPLE____033": "=begin comment\n\n=head2 Example\n# Example for set-return-on-cancel\n\n=end comment\n"
"____EXAMPLE____034": "=begin comment\n\n=head2 Example\n# Example for set-source-tag\n\n=end comment\n"
"____EXAMPLE____035": "=begin comment\n\n=head2 Example\n# Example for set-static-name\n\n=end comment\n"
"____EXAMPLE____036": "=begin comment\n\n=head2 Example\n# Example for set-task-data\n\n=end comment\n"
"____EXAMPLE____037": "=begin comment\n\n=head2 Example\n# Example for is-valid\n\n=end comment\n"
"____EXAMPLE____038": "=begin comment\n\n=head2 Example\n# Example for report-error\n\n=end comment\n"
"____EXAMPLE____039": "=begin comment\n\n=head2 Example\n# Example for report-new-error\n\n=end comment\n"
"____EXAMPLE____040": "=begin comment\ntypedef struct {\n  CakeFrostingType frosting;\n  char *message;\n} DecorationData;\n\nstatic void\ndecoration_data_free (DecorationData *decoration)\n{\n  g_free (decoration->message);\n  g_slice_free (DecorationData, decoration);\n}\n\nstatic void\nbaked_cb (Cake     *cake,\n          gpointer  user_data)\n{\n  GTask *task = user_data;\n  DecorationData *decoration = g_task_get_task_data (task);\n  GError *error = NULL;\n\n  if (cake == NULL)\n    {\n      g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,\n                               \"Go to the supermarket\");\n      g_object_unref (task);\n      return;\n    }\n\n  if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))\n    {\n      g_object_unref (cake);\n      // g_task_return_error() takes ownership of error\n      g_task_return_error (task, error);\n      g_object_unref (task);\n      return;\n    }\n\n  g_task_return_pointer (task, cake, g_object_unref);\n  g_object_unref (task);\n}\n\nvoid\nbaker_bake_cake_async (Baker               *self,\n                       guint                radius,\n                       CakeFlavor           flavor,\n                       CakeFrostingType     frosting,\n                       const char          *message,\n                       GCancellable        *cancellable,\n                       GAsyncReadyCallback  callback,\n                       gpointer             user_data)\n{\n  GTask *task;\n  DecorationData *decoration;\n  Cake  *cake;\n\n  task = g_task_new (self, cancellable, callback, user_data);\n  if (radius < 3)\n    {\n      g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,\n                               \"%ucm radius cakes are silly\",\n                               radius);\n      g_object_unref (task);\n      return;\n    }\n\n  cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);\n  if (cake != NULL)\n    {\n      // _baker_get_cached_cake() returns a reffed cake\n      g_task_return_pointer (task, cake, g_object_unref);\n      g_object_unref (task);\n      return;\n    }\n\n  decoration = g_slice_new (DecorationData);\n  decoration->frosting = frosting;\n  decoration->message = g_strdup (message);\n  g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);\n\n  _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);\n}\n\nCake *\nbaker_bake_cake_finish (Baker         *self,\n                        GAsyncResult  *result,\n                        GError       **error)\n{\n  g_return_val_if_fail (g_task_is_valid (result, self), NULL);\n\n  return g_task_propagate_pointer (G_TASK (result), error);\n}\n\n=end comment\n"
"____EXAMPLE____041": "=begin comment\ntypedef struct {\n  Cake *cake;\n  CakeFrostingType frosting;\n  char *message;\n} BakingData;\n\nstatic void\ndecoration_data_free (BakingData *bd)\n{\n  if (bd->cake)\n    g_object_unref (bd->cake);\n  g_free (bd->message);\n  g_slice_free (BakingData, bd);\n}\n\nstatic void\ndecorated_cb (Cake         *cake,\n              GAsyncResult *result,\n              gpointer      user_data)\n{\n  GTask *task = user_data;\n  GError *error = NULL;\n\n  if (!cake_decorate_finish (cake, result, &error))\n    {\n      g_object_unref (cake);\n      g_task_return_error (task, error);\n      g_object_unref (task);\n      return;\n    }\n\n  // baking_data_free() will drop its ref on the cake, so we have to\n  // take another here to give to the caller.\n  g_task_return_pointer (task, g_object_ref (cake), g_object_unref);\n  g_object_unref (task);\n}\n\nstatic gboolean\ndecorator_ready (gpointer user_data)\n{\n  GTask *task = user_data;\n  BakingData *bd = g_task_get_task_data (task);\n\n  cake_decorate_async (bd->cake, bd->frosting, bd->message,\n                       g_task_get_cancellable (task),\n                       decorated_cb, task);\n\n  return G_SOURCE_REMOVE;\n}\n\nstatic void\nbaked_cb (Cake     *cake,\n          gpointer  user_data)\n{\n  GTask *task = user_data;\n  BakingData *bd = g_task_get_task_data (task);\n  GError *error = NULL;\n\n  if (cake == NULL)\n    {\n      g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,\n                               \"Go to the supermarket\");\n      g_object_unref (task);\n      return;\n    }\n\n  bd->cake = cake;\n\n  // Bail out now if the user has already cancelled\n  if (g_task_return_error_if_cancelled (task))\n    {\n      g_object_unref (task);\n      return;\n    }\n\n  if (cake_decorator_available (cake))\n    decorator_ready (task);\n  else\n    {\n      GSource *source;\n\n      source = cake_decorator_wait_source_new (cake);\n      // Attach @source to @task’s GMainContext and have it call\n      // decorator_ready() when it is ready.\n      g_task_attach_source (task, source, decorator_ready);\n      g_source_unref (source);\n    }\n}\n\nvoid\nbaker_bake_cake_async (Baker               *self,\n                       guint                radius,\n                       CakeFlavor           flavor,\n                       CakeFrostingType     frosting,\n                       const char          *message,\n                       gint                 priority,\n                       GCancellable        *cancellable,\n                       GAsyncReadyCallback  callback,\n                       gpointer             user_data)\n{\n  GTask *task;\n  BakingData *bd;\n\n  task = g_task_new (self, cancellable, callback, user_data);\n  g_task_set_priority (task, priority);\n\n  bd = g_slice_new0 (BakingData);\n  bd->frosting = frosting;\n  bd->message = g_strdup (message);\n  g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);\n\n  _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);\n}\n\nCake *\nbaker_bake_cake_finish (Baker         *self,\n                        GAsyncResult  *result,\n                        GError       **error)\n{\n  g_return_val_if_fail (g_task_is_valid (result, self), NULL);\n\n  return g_task_propagate_pointer (G_TASK (result), error);\n}\n\n=end comment\n"
"____EXAMPLE____042": "=begin comment\ntypedef struct {\n  guint radius;\n  CakeFlavor flavor;\n  CakeFrostingType frosting;\n  char *message;\n} CakeData;\n\nstatic void\ncake_data_free (CakeData *cake_data)\n{\n  g_free (cake_data->message);\n  g_slice_free (CakeData, cake_data);\n}\n\nstatic void\nbake_cake_thread (GTask         *task,\n                  gpointer       source_object,\n                  gpointer       task_data,\n                  GCancellable  *cancellable)\n{\n  Baker *self = source_object;\n  CakeData *cake_data = task_data;\n  Cake *cake;\n  GError *error = NULL;\n\n  cake = bake_cake (baker, cake_data->radius, cake_data->flavor,\n                    cake_data->frosting, cake_data->message,\n                    cancellable, &error);\n  if (cake)\n    g_task_return_pointer (task, cake, g_object_unref);\n  else\n    g_task_return_error (task, error);\n}\n\nvoid\nbaker_bake_cake_async (Baker               *self,\n                       guint                radius,\n                       CakeFlavor           flavor,\n                       CakeFrostingType     frosting,\n                       const char          *message,\n                       GCancellable        *cancellable,\n                       GAsyncReadyCallback  callback,\n                       gpointer             user_data)\n{\n  CakeData *cake_data;\n  GTask *task;\n\n  cake_data = g_slice_new (CakeData);\n  cake_data->radius = radius;\n  cake_data->flavor = flavor;\n  cake_data->frosting = frosting;\n  cake_data->message = g_strdup (message);\n  task = g_task_new (self, cancellable, callback, user_data);\n  g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);\n  g_task_run_in_thread (task, bake_cake_thread);\n  g_object_unref (task);\n}\n\nCake *\nbaker_bake_cake_finish (Baker         *self,\n                        GAsyncResult  *result,\n                        GError       **error)\n{\n  g_return_val_if_fail (g_task_is_valid (result, self), NULL);\n\n  return g_task_propagate_pointer (G_TASK (result), error);\n}\n\n=end comment\n"
"____EXAMPLE____043": "=begin comment\nstatic void\nbake_cake_thread (GTask         *task,\n                  gpointer       source_object,\n                  gpointer       task_data,\n                  GCancellable  *cancellable)\n{\n  Baker *self = source_object;\n  CakeData *cake_data = task_data;\n  Cake *cake;\n  GError *error = NULL;\n\n  cake = bake_cake (baker, cake_data->radius, cake_data->flavor,\n                    cake_data->frosting, cake_data->message,\n                    &error);\n  if (error)\n    {\n      g_task_return_error (task, error);\n      return;\n    }\n\n  // If the task has already been cancelled, then we don’t want to add\n  // the cake to the cake cache. Likewise, we don’t  want to have the\n  // task get cancelled in the middle of updating the cache.\n  // g_task_set_return_on_cancel() will return %TRUE here if it managed\n  // to disable return-on-cancel, or %FALSE if the task was cancelled\n  // before it could.\n  if (g_task_set_return_on_cancel (task, FALSE))\n    {\n      // If the caller cancels at this point, their\n      // GAsyncReadyCallback won’t be invoked until we return,\n      // so we don’t have to worry that this code will run at\n      // the same time as that code does. But if there were\n      // other functions that might look at the cake cache,\n      // then we’d probably need a GMutex here as well.\n      baker_add_cake_to_cache (baker, cake);\n      g_task_return_pointer (task, cake, g_object_unref);\n    }\n}\n\nvoid\nbaker_bake_cake_async (Baker               *self,\n                       guint                radius,\n                       CakeFlavor           flavor,\n                       CakeFrostingType     frosting,\n                       const char          *message,\n                       GCancellable        *cancellable,\n                       GAsyncReadyCallback  callback,\n                       gpointer             user_data)\n{\n  CakeData *cake_data;\n  GTask *task;\n\n  cake_data = g_slice_new (CakeData);\n\n  ...\n\n  task = g_task_new (self, cancellable, callback, user_data);\n  g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);\n  g_task_set_return_on_cancel (task, TRUE);\n  g_task_run_in_thread (task, bake_cake_thread);\n}\n\nCake *\nbaker_bake_cake_sync (Baker               *self,\n                      guint                radius,\n                      CakeFlavor           flavor,\n                      CakeFrostingType     frosting,\n                      const char          *message,\n                      GCancellable        *cancellable,\n                      GError             **error)\n{\n  CakeData *cake_data;\n  GTask *task;\n  Cake *cake;\n\n  cake_data = g_slice_new (CakeData);\n\n  ...\n\n  task = g_task_new (self, cancellable, NULL, NULL);\n  g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);\n  g_task_set_return_on_cancel (task, TRUE);\n  g_task_run_in_thread_sync (task, bake_cake_thread);\n\n  cake = g_task_propagate_pointer (task, error);\n  g_object_unref (task);\n  return cake;\n}\n\n=end comment\n"
...